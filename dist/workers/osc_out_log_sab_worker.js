(()=>{function B({uint8View:t,dataView:o,bufferStart:e,bufferSize:r,head:l,tail:d,messageMagic:g,paddingMagic:i,headerSize:u,maxMessages:N=1/0,onMessage:U,onCorruption:a}){let s=d,O=0,C=G=>{let E=G;if(E+4<=r)return o.getUint32(e+E,!0);let A=0;for(let L=0;L<4;L++)A|=t[e+(E+L)%r]<<L*8;return A};for(;s!==l&&O<N;){let G=r-s,E;if(G>=4?E=o.getUint32(e+s,!0):E=C(s),E===i){s=0;continue}if(E!==g){a&&a(s),s=(s+1)%r;continue}let A=C((s+4)%r),L=C((s+8)%r),x=C((s+12)%r);if(A<u||A>r){a&&a(s),s=(s+1)%r;continue}let R=A-u,H=e+(s+u)%r;U(H,R,L,x),s=(s+A)%r,O++}return{newTail:s,messagesRead:O}}function m(t,o){let e=t+o;return{IN_HEAD:(e+0)/4,IN_TAIL:(e+4)/4,IN_SEQUENCE:(e+24)/4,IN_WRITE_LOCK:(e+40)/4,IN_LOG_TAIL:(e+44)/4}}var f=null,p=null,c=null,S=null,I=null,n=null,_={},D=!1,y=(...t)=>{},M=(t,o,e)=>{f=t,p=o,n=e,c=new Int32Array(f),S=new DataView(f),I=new Uint8Array(f),_=m(p,n.CONTROL_START);let r=Atomics.load(c,_.IN_HEAD);Atomics.store(c,_.IN_LOG_TAIL,r),y("Initialized, IN_LOG_TAIL set to",r)},w=t=>{let o=p+n.IN_BUFFER_START,e=n.IN_BUFFER_SIZE;if(t+4<=e)return S.getUint32(o+t,!0);let r=0;for(let l=0;l<4;l++)r|=I[o+(t+l)%e]<<l*8;return r},T=()=>{let t=Atomics.load(c,_.IN_HEAD),o=Atomics.load(c,_.IN_LOG_TAIL);if(t===o)return[];if(w(o)!==n.MESSAGE_MAGIC)return Atomics.store(c,_.IN_LOG_TAIL,t),[];let r=[],{newTail:l,messagesRead:d}=B({uint8View:I,dataView:S,bufferStart:p+n.IN_BUFFER_START,bufferSize:n.IN_BUFFER_SIZE,head:t,tail:o,messageMagic:n.MESSAGE_MAGIC,paddingMagic:n.PADDING_MAGIC,headerSize:n.MESSAGE_HEADER_SIZE,maxMessages:100,onMessage:(g,i,u,N)=>{let U=new Uint8Array(i);for(let a=0;a<i;a++)U[a]=I[g+a];r.push({sourceId:N,oscData:U,sequence:u})},onCorruption:g=>{if(T._corruptCount||(T._corruptCount=0),T._corruptCount++,T._corruptCount<=3){let i=p+n.IN_BUFFER_START+g,u=S.getUint32(i,!0),N=I[i],U=I[i+1],a=I[i+2],s=I[i+3],O=Atomics.load(c,_.IN_TAIL);console.error(`[OSCOutLogWorker] Corrupted message at position ${g}: head=${t} logTail=${o} inTail=${O} got=0x${(u>>>0).toString(16).padStart(8,"0")} expected=0x${(n.MESSAGE_MAGIC>>>0).toString(16).padStart(8,"0")} bytes=[${N},${U},${a},${s}] bufStart=${p+n.IN_BUFFER_START} bufSize=${n.IN_BUFFER_SIZE}`)}else T._corruptCount===4&&console.error(`[OSCOutLogWorker] Suppressing further corruption logs (${T._corruptCount}+ total)`)}});return d>0&&Atomics.store(c,_.IN_LOG_TAIL,l),r},F=()=>{for(;D;)try{let t=Atomics.load(c,_.IN_HEAD),o=Atomics.load(c,_.IN_LOG_TAIL);t===o&&Atomics.wait(c,_.IN_HEAD,t);let e=T();e.length>0&&self.postMessage({type:"oscLog",entries:e})}catch(t){console.error("[OSCOutLogWorker] Error in wait loop:",t),self.postMessage({type:"error",error:t.message}),Atomics.wait(c,0,c[0],10)}},$=()=>{if(!f){console.error("[OSCOutLogWorker] Cannot start - not initialized");return}D||(D=!0,F())},b=()=>{D=!1};self.addEventListener("message",t=>{let{data:o}=t;try{switch(o.type){case"init":M(o.sharedBuffer,o.ringBufferBase,o.bufferConstants),self.postMessage({type:"initialized"});break;case"start":$();break;case"stop":b();break;default:}}catch(e){console.error("[OSCOutLogWorker] Error:",e),self.postMessage({type:"error",error:e.message})}});y("Script loaded");})();
