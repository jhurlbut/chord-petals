<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet" crossorigin="anonymous">
<title>ChordPetals</title>
<script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@magenta/music@1.23.1"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
:root{
  --bg:#1a1222;--panel:#221832;--surface:rgba(255,255,255,0.06);--text:#e8e4f0;--text-dim:#8878a0;
  --major:#F2506E;--minor:#3DADD9;--dim:#32408C;--aug:#F27329;--dom7:#F23E2E;--halfdim:#32408C;--maj7:#F2506E;--min7:#3DADD9;
}
html,body{height:100%;overflow:hidden;font-family:'Luckiest Guy','SF Pro Display',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text);
  user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;
  -webkit-touch-callout:none;
}
body{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;user-select:none;-webkit-user-select:none}

/* â”€â”€ Widget Container â”€â”€ */
.widget{
  width:100vw;max-width:500px;height:100vh;height:100dvh;
  background:var(--panel);border-radius:0;
  box-shadow:none;overflow:hidden;display:flex;flex-direction:column;
}

/* â”€â”€ Header â”€â”€ */
.widget-header{
  display:flex;align-items:center;justify-content:space-between;padding:10px 14px;
  border-bottom:1px solid rgba(255,255,255,0.06);
}
.widget-header .title{font-size:13px;font-weight:700;letter-spacing:0.5px}
.widget-header .palette{font-size:11px;color:var(--text-dim);margin-left:6px}
.header-actions{display:flex;align-items:center;gap:8px}
.header-actions button{
  background:none;border:none;color:var(--text-dim);font-size:15px;cursor:pointer;padding:2px;
  transition:color .2s;line-height:1;
}
.header-actions button:hover{color:var(--text)}
.header-actions button:disabled{opacity:0.3}

/* â”€â”€ Mode Selector â”€â”€ */
.mode-bar{
  display:flex;gap:3px;padding:8px 10px;overflow-x:auto;scrollbar-width:none;
  border-bottom:1px solid rgba(255,255,255,0.04);
}
.mode-bar::-webkit-scrollbar{display:none}
.mode-btn{
  flex-shrink:0;padding:5px 10px;border-radius:12px;border:1px solid rgba(255,255,255,0.08);
  background:transparent;color:var(--text-dim);font-size:11px;font-weight:500;
  cursor:pointer;transition:all .2s;white-space:nowrap;
}
.mode-btn.active{background:rgba(242,80,110,0.2);border-color:rgba(242,80,110,0.4);color:#F2506E}

/* â”€â”€ History â”€â”€ */
.history{
  display:flex;gap:3px;align-items:center;padding:4px 12px;font-size:10px;color:var(--text-dim);
  overflow-x:auto;scrollbar-width:none;min-height:20px;
}
.history::-webkit-scrollbar{display:none}
.history span{cursor:pointer;opacity:0.6;transition:opacity .2s;white-space:nowrap}
.history span:hover{opacity:1}
.history span:last-child{opacity:1;color:var(--text)}
.history .arrow{opacity:0.3;cursor:default}

/* â”€â”€ Flower Garden â”€â”€ */
.garden{
  position:relative;width:100%;flex:1;min-height:0;overflow:hidden;
  contain:layout style;touch-action:manipulation;
}

/* Outer rotation ring */
.rotation-ring{
  position:absolute;border-radius:50%;border:1.5px dashed rgba(255,255,255,0.1);
  pointer-events:none;cursor:grab;
}
.rotation-ring:active{cursor:grabbing}

/* Delete zone ring â€” appears when dragging a petal */
.delete-ring{
  position:absolute;border-radius:50%;border:2px dashed rgba(242,80,110,0.0);
  pointer-events:none;transition:border-color .2s, box-shadow .2s;
  z-index:1;
}
.delete-ring.active{border-color:rgba(242,80,110,0.7);box-shadow:0 0 20px rgba(242,80,110,0.15)}
.delete-ring.danger{border-color:rgba(242,80,110,1);box-shadow:0 0 30px rgba(242,80,110,0.3);animation:pulse-ring .6s ease infinite alternate}
@keyframes pulse-ring{from{border-color:rgba(242,80,110,0.7)}to{border-color:rgba(242,80,110,1)}}

/* Center chord */
.center-chord{
  position:absolute;width:76px;height:76px;border-radius:50%;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  background:#32408C;border:none;
  z-index:10;cursor:pointer;transition:transform .15s,box-shadow .3s;
  transform:translate(-50%,-50%);
}
/* Larger invisible tap target around center */
.center-chord::before{
  content:'';position:absolute;top:-12px;left:-12px;right:-12px;bottom:-12px;border-radius:50%;
}
.center-chord:active{transform:translate(-50%,-50%) scale(0.93)}
.center-chord .name{font-size:22px;font-weight:700;line-height:1}
.center-chord .sub{font-size:9px;color:var(--text-dim);margin-top:1px}

/* Petals */
.petal{
  position:absolute;width:56px;height:56px;border-radius:50%;
  display:flex;align-items:center;justify-content:center;
  cursor:pointer;z-index:5;
  transition:transform .45s cubic-bezier(.4,0,.2,1),box-shadow .2s,width .15s,height .15s;
  will-change:transform;
  touch-action:manipulation;
}
.petal.entering{opacity:0;transform:translate(-50%,-50%) scale(0.3)}
.petal .petal-label{
  font-size:12px;font-weight:700;color:#fff;text-shadow:none;
  pointer-events:none;text-align:center;line-height:1.1;
}
.petal-rings{position:absolute;top:0;left:0;pointer-events:none;border-radius:50%}
.petal.selected{box-shadow:0 0 0 3px rgba(255,255,255,0.5)!important}
.petal.dragging{
  width:62px;height:62px;z-index:20;
  box-shadow:none!important;
  transition:width .1s,height .1s,box-shadow .1s;
}

/* â”€â”€ +/- buttons â”€â”€ */
.petal-count{
  position:absolute;bottom:8px;right:8px;display:flex;gap:6px;z-index:25;
}
.petal-count button{
  width:36px;height:36px;border-radius:50%;border:1px solid rgba(255,255,255,0.25);
  background:rgba(255,255,255,0.12);color:var(--text);font-size:20px;line-height:1;
  cursor:pointer;display:flex;align-items:center;justify-content:center;
  touch-action:manipulation;-webkit-tap-highlight-color:rgba(255,255,255,0.1);
}
.petal-count button:active{background:rgba(255,255,255,0.3)}

/* â”€â”€ Bottom Toolbar â”€â”€ */
.toolbar{
  display:flex;align-items:center;justify-content:center;gap:16px;
  padding:8px 14px 10px;border-top:1px solid rgba(255,255,255,0.06);
}
.tool-btn{
  background:none;border:none;color:var(--text-dim);font-size:16px;cursor:pointer;
  padding:4px;transition:color .2s;position:relative;
}
.tool-btn:hover,.tool-btn.active{color:var(--text)}
.tool-btn.active::after{
  content:'';position:absolute;bottom:0;left:50%;transform:translateX(-50%);
  width:4px;height:4px;border-radius:50%;background:var(--major);
}
.tool-btn.loading{animation:spin 1s linear infinite}
@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}
.improv-loading{display:none;align-items:center;gap:6px;padding:6px 0;color:var(--text-dim);font-size:12px}
.improv-loading.show{display:flex}
.improv-loading .spinner{width:14px;height:14px;border:2px solid var(--text-dim);border-top-color:var(--major);border-radius:50%;animation:spin 0.8s linear infinite}

/* â”€â”€ Key Selector Popup â”€â”€ */
.key-popup{
  position:absolute;z-index:50;background:#16162a;border-radius:14px;
  border:none;box-shadow:none;
  padding:10px;display:none;
  left:50%;top:50%;transform:translate(-50%,-50%);
}
.key-popup.show{display:grid;grid-template-columns:repeat(4,1fr);gap:4px}
.key-popup button{
  width:40px;height:36px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);
  background:rgba(255,255,255,0.06);color:var(--text);font-size:13px;font-weight:600;
  cursor:pointer;transition:all .15s;
}
.key-popup button:hover{background:rgba(242,80,110,0.25);border-color:rgba(242,80,110,0.5)}
.key-popup button.current{background:rgba(242,80,110,0.3);border-color:rgba(242,80,110,0.6)}

/* â”€â”€ MIDI Panel â”€â”€ */
.midi-panel{
  position:fixed;bottom:0;left:50%;transform:translate(-50%,100%);
  width:360px;max-width:96vw;max-height:70vh;max-height:70dvh;
  overflow-y:scroll;overscroll-behavior:contain;
  background:rgba(16,16,30,0.97);
  border-top:1px solid rgba(255,255,255,0.1);padding:14px 16px 20px;
  transition:transform .3s ease;z-index:100;border-radius:14px 14px 0 0;
  backdrop-filter:blur(16px);-webkit-backdrop-filter:blur(16px);
  -webkit-overflow-scrolling:touch;touch-action:pan-y;
}
.midi-panel.open{transform:translate(-50%,0)}
.midi-panel h3{font-size:13px;font-weight:600;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center}
.midi-panel h3 .panel-close{background:none;border:none;color:var(--text-dim);font-size:18px;cursor:pointer;padding:0 2px;line-height:1}
.midi-panel h3 .panel-close:hover{color:var(--text)}
.midi-panel label{display:block;font-size:11px;color:var(--text-dim);margin:6px 0 3px}
.midi-panel select{
  width:100%;padding:5px 7px;border-radius:6px;border:1px solid rgba(255,255,255,0.1);
  background:rgba(255,255,255,0.06);color:var(--text);font-size:12px;outline:none;
}
.midi-row{display:flex;gap:10px}.midi-row>*{flex:1}
.midi-toggle{display:flex;align-items:center;gap:8px;font-size:11px;color:var(--text-dim);cursor:pointer;margin-top:4px;margin-bottom:8px}
.midi-toggle input{display:none}
.midi-toggle .sw{
  width:36px;height:20px;border-radius:10px;background:rgba(255,255,255,0.12);position:relative;transition:background .2s;
  border:1px solid rgba(255,255,255,0.08);flex-shrink:0;
}
.midi-toggle input:checked+.sw{background:rgba(242,80,110,0.6);border-color:rgba(242,80,110,0.4)}
.midi-toggle .sw::after{
  content:'';position:absolute;top:2px;left:2px;width:14px;height:14px;border-radius:50%;
  background:rgba(255,255,255,0.5);transition:transform .2s,background .2s;
}
.midi-toggle input:checked+.sw::after{transform:translateX(16px);background:#fff}
.midi-note{font-size:10px;color:var(--text-dim);margin-top:6px;opacity:0.6}
.voice-opt{flex:1;padding:6px 4px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.06);color:var(--text);font-size:11px;cursor:pointer;font-family:inherit}
.voice-opt.active{background:rgba(242,80,110,0.25);border-color:rgba(242,80,110,0.5)}
.midi-detected{font-size:10px;color:var(--min7);text-align:center;min-height:14px;padding:2px 0}
</style>
</head>
<body>

<div class="widget">
  <!-- Header -->
  <div class="widget-header">
    <div><span class="title">ChordPetals</span><span class="palette">Palette 1</span><span id="engineBadge" style="font-size:9px;padding:1px 5px;border-radius:6px;margin-left:6px;background:rgba(255,255,255,0.08);color:var(--text-dim)">Web Audio</span></div>
    <div class="header-actions">
      <button id="undoBtn" onclick="undoHistory()" title="Undo">â†©</button>
      <button id="redoBtn" onclick="redoHistory()" title="Redo" disabled>â†ª</button>
      <button onclick="toggleMidiPanel()" title="Settings">âš™</button>
    </div>
  </div>

  <!-- Mode bar -->
  <div class="mode-bar" id="modeBar"></div>

  <!-- History -->
  <div class="history" id="history"></div>

  <!-- MIDI detected -->
  <div class="midi-detected" id="midiDetected"></div>

  <!-- Flower garden -->
  <div class="garden" id="garden">
      <div class="rotation-ring" id="rotRing"></div>
      <div class="delete-ring" id="deleteRing"></div>
      <div class="center-chord" id="center">
        <div class="name" id="centerName">C</div>
        <div class="sub" id="centerSub">major</div>
      </div>
      <div class="key-popup" id="keyPopup"></div>
      <div class="petal-count">
        <button id="removeBtn">âˆ’</button>
        <span id="petalCountLabel" style="color:var(--text-dim);font-size:12px;display:flex;align-items:center">5</span>
        <button id="addBtn">+</button>
      </div>
  </div>
  <!-- Bottom toolbar -->
  <div class="toolbar">
    <button class="tool-btn active" id="eyeBtn" onclick="toggleNames()" title="Show/hide names">ğŸ‘</button>
    <button class="tool-btn" onclick="copyChords()" title="Copy chords">ğŸ“‹</button>
    <button class="tool-btn active" id="soundBtn" onclick="toggleSound()" title="Sound">ğŸ”Š</button>
    <button class="tool-btn" id="lockBtn" onclick="toggleLock()" title="Lock root">ğŸ”“</button>
    <button class="tool-btn" id="voiceBtn" onclick="toggleVoicePanel()" title="Voicing">ğŸ›</button>
    <button class="tool-btn" id="improvBtn" onclick="toggleImprov()" title="AI Improvise">ğŸµ</button>
    <button class="tool-btn" onclick="toggleMidiPanel()" title="MIDI">ğŸ¹</button>
    <button class="tool-btn" onclick="document.getElementById('debugPanel').style.display=document.getElementById('debugPanel').style.display==='none'?'block':'none'" title="Debug Layout">ğŸ”§</button>
  </div>
</div>

<!-- Voicing Panel â€” full-screen overlay -->
<div class="midi-panel" id="voicePanel">
  <h3><span>ğŸ› Voicing & Phrasing</span><button class="panel-close" onclick="document.getElementById('voicePanel').classList.remove('open')">âœ•</button></h3>

  <!-- Instruments â€” grouped at top -->
  <label>Web Synths</label>
  <div style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:4px">
    <button class="voice-opt active" data-synth="warm" onclick="setSynth('warm')">Warm</button>
    <button class="voice-opt" data-synth="bright" onclick="setSynth('bright')">Bright</button>
    <button class="voice-opt" data-synth="pad" onclick="setSynth('pad')">Pad</button>
    <button class="voice-opt" data-synth="keys" onclick="setSynth('keys')">Keys</button>
    <button class="voice-opt" data-synth="pluck" onclick="setSynth('pluck')">Pluck</button>
    <button class="voice-opt" data-synth="organ" onclick="setSynth('organ')">Organ</button>
  </div>
  <label>âš¡ Sonic Pi</label>
  <div style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:8px;opacity:0.4;transition:opacity 0.3s" id="sonicPiSynthGroup">
    <button class="voice-opt" data-synth="sp-prophet" onclick="setSynth('sp-prophet')">Prophet</button>
    <button class="voice-opt" data-synth="sp-blade" onclick="setSynth('sp-blade')">Blade</button>
    <button class="voice-opt" data-synth="sp-dark_ambience" onclick="setSynth('sp-dark_ambience')">Dark Amb</button>
    <button class="voice-opt" data-synth="sp-piano" onclick="setSynth('sp-piano')">Piano</button>
    <button class="voice-opt" data-synth="sp-pretty_bell" onclick="setSynth('sp-pretty_bell')">Bell</button>
  </div>

  <div style="border-top:1px solid rgba(255,255,255,0.06);margin:8px 0"></div>

  <!-- Voicing controls -->
  <div style="display:flex;gap:12px;margin-bottom:8px">
    <div style="flex:1">
      <label>Voicing</label>
      <div style="display:flex;gap:4px">
        <button class="voice-opt active" data-voice="close" onclick="setVoiceMode('close')">Close</button>
        <button class="voice-opt" data-voice="open" onclick="setVoiceMode('open')">Open</button>
        <button class="voice-opt" data-voice="spread" onclick="setVoiceMode('spread')">Spread</button>
      </div>
    </div>
    <div style="flex:0 0 100px">
      <label>Octave</label>
      <div style="display:flex;gap:4px;align-items:center">
        <button class="voice-opt" onclick="shiftOctave(-1)" style="flex:0 0 36px">â–¼</button>
        <span id="octaveLabel" style="flex:1;text-align:center;color:var(--text);font-size:13px">0</span>
        <button class="voice-opt" onclick="shiftOctave(1)" style="flex:0 0 36px">â–²</button>
      </div>
    </div>
  </div>

  <div style="display:flex;gap:12px;margin-bottom:8px">
    <div style="flex:1">
      <label>Phrasing</label>
      <div style="display:flex;gap:4px">
        <button class="voice-opt active" data-phrase="block" onclick="setPhraseMode('block')">Block</button>
        <button class="voice-opt" data-phrase="strum" onclick="setPhraseMode('strum')">Strum</button>
        <button class="voice-opt" data-phrase="arpeggio" onclick="setPhraseMode('arpeggio')">Arpeggio</button>
      </div>
    </div>
    <div style="flex:0 0 100px">
      <label>Bass Root</label>
      <label class="midi-toggle"><input type="checkbox" id="bassToggle" onchange="toggleBass(this.checked)"><span class="sw"></span>On</label>
    </div>
  </div>

  <div style="border-top:1px solid rgba(255,255,255,0.06);margin:8px 0"></div>

  <!-- SuperSonic FX -->
  <label>âš¡ SuperSonic FX</label>
  <div style="display:flex;gap:12px;margin-bottom:4px">
    <div style="flex:1">
      <label>Reverb: <span id="ssReverbVal" style="color:var(--text)">30%</span></label>
      <input type="range" min="0" max="100" step="5" value="30" style="width:100%" id="ssReverbSlider" oninput="setSSReverb(this.value)">
    </div>
    <div style="flex:1">
      <label>Delay: <span id="ssDelayVal" style="color:var(--text)">Off</span></label>
      <input type="range" min="0" max="100" step="5" value="0" style="width:100%" id="ssDelaySlider" oninput="setSSDelay(this.value)">
    </div>
  </div>
  <label>Delay Time: <span id="ssDelayTimeVal" style="color:var(--text)">300ms</span></label>
  <input type="range" min="50" max="800" step="25" value="300" style="width:100%;margin-bottom:8px" id="ssDelayTimeSlider" oninput="setSSDelayTime(this.value)">
</div>

<!-- Improv Settings Panel -->
<div class="midi-panel" id="improvPanel">
  <h3><span>ğŸµ AI Improvisation</span><button class="panel-close" onclick="document.getElementById('improvPanel').classList.remove('open')">âœ•</button></h3>
  <div class="improv-loading" id="improvLoadingBar"><div class="spinner"></div><span id="improvLoadingText">Loading modelâ€¦</span></div>
  <label>Improvisation</label>
  <label class="midi-toggle"><input type="checkbox" id="improvToggle" onchange="setImprovEnabled(this.checked)"><span class="sw"></span>Enable</label>
  <label>Model</label>
  <div style="display:flex;gap:4px;margin-bottom:8px">
    <button class="voice-opt" data-improv-model="rnn" onclick="setImprovModel('rnn')">ImprovRNN</button>
    <button class="voice-opt active" data-improv-model="vae" onclick="setImprovModel('vae')">MelodyVAE</button>
  </div>
  <div id="improvContinuousRow">
    <label>Continuous</label>
    <label class="midi-toggle"><input type="checkbox" id="improvContToggle" onchange="setImprovContinuous(this.checked)" checked><span class="sw"></span>Loop &amp; interpolate between chords</label>
  </div>
  <label>Accompaniment Sound</label>
  <div style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:8px">
    <button class="voice-opt" data-improv-synth="warm" onclick="setImprovSynth('warm')">Warm</button>
    <button class="voice-opt" data-improv-synth="bright" onclick="setImprovSynth('bright')">Bright</button>
    <button class="voice-opt active" data-improv-synth="pad" onclick="setImprovSynth('pad')">Pad</button>
    <button class="voice-opt" data-improv-synth="keys" onclick="setImprovSynth('keys')">Keys</button>
    <button class="voice-opt" data-improv-synth="pluck" onclick="setImprovSynth('pluck')">Pluck</button>
    <button class="voice-opt" data-improv-synth="organ" onclick="setImprovSynth('organ')">Organ</button>
  </div>
  <label style="font-size:0.7em;opacity:0.6;margin-top:2px">âš¡ Sonic Pi</label>
  <div style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:8px;opacity:0.4;transition:opacity 0.3s" id="sonicPiImprovGroup">
    <button class="voice-opt" data-improv-synth="sp-prophet" onclick="setImprovSynth('sp-prophet')">Prophet</button>
    <button class="voice-opt" data-improv-synth="sp-blade" onclick="setImprovSynth('sp-blade')">Blade</button>
    <button class="voice-opt" data-improv-synth="sp-dark_ambience" onclick="setImprovSynth('sp-dark_ambience')">Dark Amb</button>
    <button class="voice-opt" data-improv-synth="sp-piano" onclick="setImprovSynth('sp-piano')">Piano</button>
    <button class="voice-opt" data-improv-synth="sp-pretty_bell" onclick="setImprovSynth('sp-pretty_bell')">Bell</button>
  </div>
  <label>Tempo: <span id="improvTempoVal" style="color:var(--text)">140bpm</span></label>
  <input type="range" min="60" max="200" step="10" value="140" style="width:100%;margin-bottom:8px" oninput="setImprovTempo(this.value)">
  <label>Length: <span id="improvStepsVal" style="color:var(--text)">4 bars</span></label>
  <div style="display:flex;gap:4px;margin-bottom:8px">
    <button class="voice-opt" onclick="setImprovSteps(8);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">Â½ bar</button>
    <button class="voice-opt" onclick="setImprovSteps(16);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">1 bar</button>
    <button class="voice-opt" onclick="setImprovSteps(32);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">2 bars</button>
    <button class="voice-opt active" onclick="setImprovSteps(64);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">4 bars</button>
  </div>
  <label>Creativity: <span id="improvTempVal" style="color:var(--text)">Gentle</span></label>
  <div style="display:flex;gap:4px;margin-bottom:8px">
    <button class="voice-opt" onclick="setImprovTemp(0.5);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">Safe</button>
    <button class="voice-opt active" onclick="setImprovTemp(0.8);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">Gentle</button>
    <button class="voice-opt" onclick="setImprovTemp(1.1);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">Balanced</button>
    <button class="voice-opt" onclick="setImprovTemp(1.5);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">Wild</button>
    <button class="voice-opt" onclick="setImprovTemp(2.0);this.parentNode.querySelectorAll('.voice-opt').forEach(b=>b.classList.remove('active'));this.classList.add('active')">Chaos</button>
  </div>
  <label>Volume: <span id="improvGainVal" style="color:var(--text)">3%</span></label>
  <input type="range" min="0.02" max="0.3" step="0.01" value="0.03" style="width:100%;margin-bottom:8px" oninput="setImprovGain(this.value)">
  <label>Octave</label>
  <div style="display:flex;gap:4px;margin-bottom:8px;align-items:center">
    <button class="voice-opt" onclick="setImprovOctave(-1)" style="flex:0 0 48px">â–¼</button>
    <span id="improvOctLabel" style="flex:1;text-align:center;color:var(--text);font-size:13px">-1</span>
    <button class="voice-opt" onclick="setImprovOctave(1)" style="flex:0 0 48px">â–²</button>
  </div>
</div>

<!-- Debug Layout Panel -->
<div id="debugPanel" style="display:none;position:fixed;bottom:60px;left:10px;right:10px;background:rgba(20,10,30,0.95);border:1px solid #F2506E;border-radius:12px;padding:12px;z-index:9999;font-size:12px;color:#fff;max-height:50vh;overflow-y:auto;">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
    <b style="color:#F2506E;">ğŸ”§ Layout Debug</b>
    <span onclick="document.getElementById('debugPanel').style.display='none'" style="cursor:pointer;font-size:18px;">âœ•</span>
  </div>
  <label>Spread (orbit distance): <span id="dbgSpreadVal">0.55</span></label>
  <input type="range" id="dbgSpread" min="0.3" max="2.0" step="0.05" value="0.55" style="width:100%" oninput="dbgSpread=+this.value;document.getElementById('dbgSpreadVal').textContent=this.value;render()">
  <label>Overlap: <span id="dbgOverlapVal">0.24</span></label>
  <input type="range" id="dbgOverlap" min="-0.3" max="0.5" step="0.02" value="0.24" style="width:100%" oninput="dbgOverlap=+this.value;document.getElementById('dbgOverlapVal').textContent=this.value;render()">
  <label>Ring offset (fraction of petal angle): <span id="dbgOffsetVal">0.50</span></label>
  <input type="range" id="dbgOffset" min="0" max="1.0" step="0.25" value="0.50" style="width:100%" oninput="dbgRingOffset=+this.value;document.getElementById('dbgOffsetVal').textContent=this.value;render()">
  <label>Padding: <span id="dbgMinVal">3</span></label>
  <input type="range" id="dbgMin" min="0" max="20" step="1" value="3" style="width:100%" oninput="dbgMinGap=+this.value;document.getElementById('dbgMinVal').textContent=this.value;render()">
  <label>Vertical center: <span id="dbgVCVal">0.38</span></label>
  <input type="range" id="dbgVC" min="0.3" max="0.7" step="0.01" value="0.38" style="width:100%" oninput="dbgVertCenter=+this.value;document.getElementById('dbgVCVal').textContent=this.value;render()">
  <label>Petal size: <span id="dbgPSVal">0.90</span></label>
  <input type="range" id="dbgPS" min="0.4" max="1.5" step="0.05" value="0.90" style="width:100%" oninput="dbgPetalScale=+this.value;document.getElementById('dbgPSVal').textContent=this.value;render()">
</div>

<!-- MIDI Panel -->
<div class="midi-panel" id="midiPanel">
  <h3><span>ğŸ¹ MIDI Settings</span><button class="panel-close" onclick="document.getElementById('midiPanel').classList.remove('open')">âœ•</button></h3>
  <label>MIDI Output</label>
  <select id="midiOut"><option value="">None</option></select>
  <label>MIDI Input</label>
  <select id="midiIn"><option value="">None</option></select>
  <div class="midi-row">
    <div><label>Channel</label><select id="midiCh"></select></div>
  </div>
  <label class="midi-toggle"><input type="checkbox" id="midiSendToggle" checked><span class="sw"></span>Send MIDI on tap</label>
  <label class="midi-toggle"><input type="checkbox" id="midiNavToggle"><span class="sw"></span>Auto-navigate on input</label>
  <div style="border-top:1px solid rgba(255,255,255,0.06);margin:10px 0 6px"></div>
  <label>Bluetooth MIDI</label>
  <button class="voice-opt" id="bleMidiBtn" onclick="connectBLEMIDI()" style="width:100%;margin-bottom:6px">ğŸ”— Connect BLE Device</button>
  <div id="bleMidiStatus" style="font-size:10px;color:var(--text-dim);min-height:14px"></div>
  <div class="midi-note" id="midiNote"></div>
</div>

<!-- Pre-load SuperSonic as ES module (iOS WebKit needs same-origin for AudioWorklet) -->
<script type="module">
import { SuperSonic } from './dist/supersonic.js';
window._SuperSonicClass = SuperSonic;
window.dispatchEvent(new Event('supersonic-ready'));
</script>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MUSIC THEORY ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const FLAT_MAP = {'C#':'Db','D#':'Eb','F#':'Gb','G#':'Ab','A#':'Bb'};
const MAJOR_SCALE = [0,2,4,5,7,9,11];
const MINOR_SCALE = [0,2,3,5,7,8,10];

// Desaturate and darken a hex color for text
function desatColor(hex,sat=0.4,light=0.55){
  let r=parseInt(hex.slice(1,3),16)/255,g=parseInt(hex.slice(3,5),16)/255,b=parseInt(hex.slice(5,7),16)/255;
  const max=Math.max(r,g,b),min=Math.min(r,g,b);
  let h,s,l=(max+min)/2;
  if(max===min){h=s=0;}else{const d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=((g-b)/d+(g<b?6:0))/6;break;case g:h=((b-r)/d+2)/6;break;case b:h=((r-g)/d+4)/6;break;}}
  s*=sat;l=light;
  function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}
  const q=l<0.5?l*(1+s):l+s-l*s,p=2*l-q;
  const ro=Math.round(hue2rgb(p,q,h+1/3)*255),go=Math.round(hue2rgb(p,q,h)*255),bo=Math.round(hue2rgb(p,q,h-1/3)*255);
  return `rgb(${ro},${go},${bo})`;
}
const QUALITY = {
  major:{intervals:[0,4,7],color:'var(--major)',solid:'#F2506E'},
  minor:{intervals:[0,3,7],color:'var(--minor)',solid:'#3DADD9'},
  dim:{intervals:[0,3,6],color:'var(--dim)',solid:'#32408C'},
  aug:{intervals:[0,4,8],color:'var(--aug)',solid:'#F27329'},
  dom7:{intervals:[0,4,7,10],color:'var(--dom7)',solid:'#F23E2E'},
  maj7:{intervals:[0,4,7,11],color:'var(--maj7)',solid:'#F2506E'},
  min7:{intervals:[0,3,7,10],color:'var(--min7)',solid:'#3DADD9'},
  halfdim:{intervals:[0,3,6,10],color:'var(--halfdim)',solid:'#32408C'},
};

// Voicing extensions: each ring level adds notes
// Level 0 = triad (3 notes), 1 = 7th (4), 2 = 9th (5), 3 = 11th (6)
const VOICING_EXTENSIONS = {
  major:  [[0,4,7],[0,4,7,11],[0,4,7,11,14],[0,4,7,11,14,17]],
  minor:  [[0,3,7],[0,3,7,10],[0,3,7,10,14],[0,3,7,10,14,17]],
  dim:    [[0,3,6],[0,3,6,9], [0,3,6,9,14], [0,3,6,9,14,17]],
  aug:    [[0,4,8],[0,4,8,11],[0,4,8,11,14],[0,4,8,11,14,18]],
  dom7:   [[0,4,7],[0,4,7,10],[0,4,7,10,14],[0,4,7,10,14,17]],
  maj7:   [[0,4,7],[0,4,7,11],[0,4,7,11,14],[0,4,7,11,14,17]],
  min7:   [[0,3,7],[0,3,7,10],[0,3,7,10,14],[0,3,7,10,14,17]],
  halfdim:[[0,3,6],[0,3,6,10],[0,3,6,10,14],[0,3,6,10,14,17]],
};
const VOICING_LABELS = ['','7','9','11'];

// Alternate voicings: inversions, drop voicings, spread, close high
// Each entry maps to arrays of voicing variants per note count (triad=3, 7th=4, etc.)
// Voicing 0 = root position (default), 1+ = alternates
const ALT_VOICINGS = {
  major: {
    3: [
      {name:'Root',    intervals:[0,4,7]},
      {name:'1st Inv', intervals:[4,7,12]},        // E in bass
      {name:'2nd Inv', intervals:[7,12,16]},        // G in bass
      {name:'Close Hi',intervals:[12,16,19]},       // octave up close
      {name:'Spread',  intervals:[0,12,16]},        // root + octave spread
      {name:'Drop 2',  intervals:[4,12,19]},        // drop 2nd voice
    ],
    4: [
      {name:'Root',    intervals:[0,4,7,11]},
      {name:'1st Inv', intervals:[4,7,11,12]},
      {name:'2nd Inv', intervals:[7,11,12,16]},
      {name:'3rd Inv', intervals:[11,12,16,19]},
      {name:'Drop 2',  intervals:[4,12,16,23]},     // drop 2 spread
      {name:'Shell',   intervals:[0,4,11,19]},      // shell voicing (R-3-7-5up)
    ],
  },
  minor: {
    3: [
      {name:'Root',    intervals:[0,3,7]},
      {name:'1st Inv', intervals:[3,7,12]},
      {name:'2nd Inv', intervals:[7,12,15]},
      {name:'Close Hi',intervals:[12,15,19]},
      {name:'Spread',  intervals:[0,12,15]},
      {name:'Drop 2',  intervals:[3,12,19]},
    ],
    4: [
      {name:'Root',    intervals:[0,3,7,10]},
      {name:'1st Inv', intervals:[3,7,10,12]},
      {name:'2nd Inv', intervals:[7,10,12,15]},
      {name:'3rd Inv', intervals:[10,12,15,19]},
      {name:'Drop 2',  intervals:[3,12,15,22]},
      {name:'Shell',   intervals:[0,3,10,19]},
    ],
  },
  dim: {
    3: [
      {name:'Root',    intervals:[0,3,6]},
      {name:'1st Inv', intervals:[3,6,12]},
      {name:'2nd Inv', intervals:[6,12,15]},
    ],
    4: [
      {name:'Root',    intervals:[0,3,6,9]},
      {name:'1st Inv', intervals:[3,6,9,12]},
      {name:'2nd Inv', intervals:[6,9,12,15]},
      {name:'3rd Inv', intervals:[9,12,15,18]},
    ],
  },
  dom7: {
    3: [
      {name:'Root',    intervals:[0,4,7]},
      {name:'1st Inv', intervals:[4,7,12]},
      {name:'2nd Inv', intervals:[7,12,16]},
      {name:'Tritone',intervals:[6,10,12]},         // tritone sub voicing
    ],
    4: [
      {name:'Root',    intervals:[0,4,7,10]},
      {name:'1st Inv', intervals:[4,7,10,12]},
      {name:'2nd Inv', intervals:[7,10,12,16]},
      {name:'3rd Inv', intervals:[10,12,16,19]},
      {name:'Shell',   intervals:[0,4,10,19]},
      {name:'UpStr',   intervals:[6,10,13,18]},     // upper structure (tritone away)
    ],
  },
};
// Fallback: generate inversions for any quality
function getAltVoicings(quality, noteCount){
  const alts=ALT_VOICINGS[quality];
  if(alts&&alts[noteCount])return alts[noteCount];
  // Auto-generate inversions from VOICING_EXTENSIONS
  const ext=VOICING_EXTENSIONS[quality];
  if(!ext)return null;
  const voiceIdx=Math.max(0,noteCount-3);
  const base=ext[voiceIdx]||ext[0];
  const result=[{name:'Root',intervals:[...base]}];
  for(let inv=1;inv<base.length;inv++){
    const rotated=base.slice(inv).concat(base.slice(0,inv).map(n=>n+12));
    result.push({name:`Inv ${inv}`,intervals:rotated});
  }
  return result;
}

function noteName(idx, preferFlat=false){
  const n=NOTES[((idx%12)+12)%12];
  return preferFlat&&FLAT_MAP[n]?FLAT_MAP[n]:n;
}
function qualitySuffix(q){
  return {major:'',minor:'m',dim:'Â°',aug:'+',dom7:'7',maj7:'maj7',min7:'m7',halfdim:'Ã¸7'}[q]||'';
}
function chord(root,quality,numeral=''){
  return {root,quality,numeral,name:noteName(root,true)+qualitySuffix(quality)};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HARMONY MODES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MODES = [
  {id:'diatonic',label:'Diatonic',fn:getDiatonic},
  {id:'fifths',label:'Circle of 5ths',fn:getCircleOfFifths},
  {id:'relative',label:'Relative/Parallel',fn:getRelativeParallel},
  {id:'tritone',label:'Tritone Subs',fn:getTritoneSubs},
  {id:'modal',label:'Modal Interchange',fn:getModalInterchange},
];

const SCALE_INTERVALS={
  major:[0,2,4,5,7,9,11],
  minor:[0,2,3,5,7,8,10],
  diminished:[0,2,3,5,6,8,9,11],
  lydian:[0,2,4,6,7,9,11],
};
const SCALE_QUALS={
  major:['major','minor','minor','major','major','minor','dim'],
  minor:['minor','dim','major','minor','minor','major','major'],
  diminished:['dim','dim','dim','dim','dim','dim','dim','dim'],
  lydian:['major','major','minor','dim','major','minor','minor'],
};
const SCALE_NUMS={
  major:['I','ii','iii','IV','V','vi','viiÂ°'],
  minor:['i','iiÂ°','III','iv','v','VI','VII'],
  diminished:['iÂ°','iiÂ°','iiiÂ°','ivÂ°','vÂ°','viÂ°','viiÂ°','viiiÂ°'],
  lydian:['I','II','iii','#ivÂ°','V','vi','vii'],
};
function getDiatonic(root){
  const sc=currentScale||'major';
  const intervals=SCALE_INTERVALS[sc]||SCALE_INTERVALS.major;
  const quals=SCALE_QUALS[sc]||SCALE_QUALS.major;
  const nums=SCALE_NUMS[sc]||SCALE_NUMS.major;
  return intervals.map((s,i)=>chord((root+s)%12,quals[i],nums[i]));
}
function getCircleOfFifths(root){
  const steps=[-7,-5,-2,0,2,5,7];
  const labels=['IV of IV','â™­VII','IV','I','V','II (V/V)','VI'];
  return steps.map((s,i)=>{const n=((root+s)%12+12)%12;return chord(n,'major',labels[i]);});
}
function getRelativeParallel(root){
  return [
    chord((root+9)%12,'minor','vi (rel min)'),chord((root+3)%12,'major','â™­III (rel maj of min)'),
    chord(root,'minor','i (parallel min)'),chord((root+5)%12,'major','IV'),
    chord((root+7)%12,'major','V'),chord((root+8)%12,'major','â™­VI (from min)'),
  ];
}
function getTritoneSubs(root){
  return [
    chord((root+6)%12,'dom7','â™­II7 (tritone sub)'),chord((root+7)%12,'dom7','V7'),
    chord((root+2)%12,'dom7','V7/V (sec dom)'),chord((root+9)%12,'dom7','V7/ii'),
    chord((root+4)%12,'dom7','V7/IV'),chord((root+11)%12,'dom7','V7/iii'),
    chord((root+1)%12,'dom7','â™­II7/V'),
  ];
}
function getModalInterchange(root){
  return [
    chord((root+3)%12,'major','â™­III (dorian)'),chord((root+5)%12,'minor','iv (aeolian)'),
    chord((root+8)%12,'major','â™­VI (aeolian)'),chord((root+10)%12,'major','â™­VII (mixolydian)'),
    chord((root+1)%12,'major','â™­II (phrygian)'),chord((root+6)%12,'dim','#ivÂ° (lydian)'),
    chord((root+3)%12,'minor','â™­iii (phrygian)'),
  ];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SUPERSONIC (SuperCollider WASM) ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let sonic=null; // SuperSonic instance
let sonicReady=false;
let sonicLoading=false;

// Map synth presets to Sonic Pi synthdef names
const SONIC_SYNTH_MAP={
  warm:'sonic-pi-prophet',
  bright:'sonic-pi-blade',
  pad:'sonic-pi-dark_ambience',
  keys:'sonic-pi-piano',
  pluck:'sonic-pi-pluck',
  organ:'sonic-pi-pretty_bell',
  // Direct Sonic Pi synth presets (selectable in UI)
  'sp-prophet':'sonic-pi-prophet',
  'sp-blade':'sonic-pi-blade',
  'sp-dark_ambience':'sonic-pi-dark_ambience',
  'sp-piano':'sonic-pi-piano',
  'sp-pretty_bell':'sonic-pi-pretty_bell',
};
// Which presets are Sonic Piâ€“native (require SuperSonic)
const SONIC_PI_PRESETS=new Set(['sp-prophet','sp-blade','sp-dark_ambience','sp-piano','sp-pretty_bell']);
const SONIC_SYNTHDEFS_TO_LOAD=Object.values(SONIC_SYNTH_MAP).filter((v,i,a)=>a.indexOf(v)===i);

async function initSuperSonic(){
  if(sonic||sonicLoading)return;
  sonicLoading=true;
  const badge=document.getElementById('engineBadge');
  if(badge){badge.textContent='â³ Loadingâ€¦';badge.style.color='var(--text-dim)';}
  
  // Check for required browser features first
  if(!window.AudioWorklet && !(window.AudioContext && AudioContext.prototype.audioWorklet)){
    console.warn('SuperSonic: AudioWorklet not supported');
    sonicLoading=false;
    if(badge){badge.textContent='Web Audio';badge.style.background='rgba(255,255,255,0.08)';badge.style.color='var(--text-dim)';}
    return;
  }
  // SuperSonic WASM requires SharedArrayBuffer (even in postMessage mode)
  if(typeof SharedArrayBuffer==='undefined'){
    console.warn('SuperSonic: SharedArrayBuffer not available (needs COOP/COEP headers)');
    sonicLoading=false;
    if(badge){badge.textContent='Web Audio';badge.title='SuperSonic needs SharedArrayBuffer (requires server COOP/COEP headers)';badge.style.background='rgba(255,255,255,0.08)';badge.style.color='var(--text-dim)';}
    return;
  }
  
  const mkTimeout=(ms)=>new Promise((_,reject)=>setTimeout(()=>reject(new Error('timeout')),ms));
  
  try{
    console.log('SuperSonic: waiting for moduleâ€¦');
    // Wait for the pre-loaded ES module (or timeout after 10s)
    if(!window._SuperSonicClass){
      await Promise.race([
        new Promise(r=>{window.addEventListener('supersonic-ready',r,{once:true});}),
        mkTimeout(10000)
      ]);
    }
    if(!window._SuperSonicClass) throw new Error('Module failed to load');
    console.log('SuperSonic: module ready, creating instanceâ€¦');
    const SuperSonic=window._SuperSonicClass;
    sonic=new SuperSonic({
      baseURL:'./dist/',
      mode: 'postMessage',
      synthdefBaseURL:'https://unpkg.com/supersonic-scsynth-synthdefs@latest/synthdefs/',
      sampleBaseURL:'https://unpkg.com/supersonic-scsynth-samples@latest/samples/',
    });
    sonic.on&&sonic.on('error',(e)=>console.error('SuperSonic event error:',e));
    console.log('SuperSonic: calling init()â€¦');
    if(badge){badge.textContent='â³ Bootingâ€¦';}
    const initResult=sonic.init();
    initResult.catch(e=>console.error('SuperSonic init rejected:',e));
    await Promise.race([initResult, mkTimeout(20000)]);
    console.log('SuperSonic: init done! loading synthdefsâ€¦');
    if(badge){badge.textContent='â³ Synthsâ€¦';}
    const sdResult=await Promise.race([sonic.loadSynthDefs(SONIC_SYNTHDEFS_TO_LOAD), mkTimeout(20000)]);
    console.log('SuperSonic: synthdefs loaded, syncingâ€¦',sdResult);
    if(badge){badge.textContent='â³ Syncâ€¦';}
    await Promise.race([sonic.sync(), mkTimeout(10000)]);
    sonicReady=true;
    sonicLoading=false;
    // Enable Sonic Pi synth buttons
    const spGroup=document.getElementById('sonicPiSynthGroup');
    if(spGroup)spGroup.style.opacity='1';
    const spImprov=document.getElementById('sonicPiImprovGroup');
    if(spImprov)spImprov.style.opacity='1';
    // Set up FX chain on SuperSonic output
    ssFxSetup=false;
    setupSSFxChain();
    // Resume SuperSonic's internal AudioContext (may be suspended on iOS)
    const ssCtx=sonic.node?.context;
    if(ssCtx&&ssCtx.state==='suspended') await ssCtx.resume();
    console.log('SuperSonic: ready! ctx state:',ssCtx?.state,'sampleRate:',ssCtx?.sampleRate);
    console.log('SuperSonic: ready');
    const ssCtxState=sonic.node?.context?.state||'?';
    if(badge){
      badge.textContent='âš¡ SuperSonic';badge.style.background='rgba(61,173,217,0.2)';badge.style.color='#3DADD9';badge.title='ctx:'+ssCtxState;
      badge.style.cursor='pointer';
      badge.addEventListener('click',()=>{
        window._useWebAudio=!window._useWebAudio;
        badge.textContent=window._useWebAudio?'ğŸ”Š Web Audio':'âš¡ SuperSonic';
        badge.style.background=window._useWebAudio?'rgba(242,80,110,0.2)':'rgba(61,173,217,0.2)';
        badge.style.color=window._useWebAudio?'#F2506E':'#3DADD9';
      });
    }
  }catch(e){
    const errMsg=(e.message||String(e)).slice(0,60);
    const failedAt=badge?badge.textContent:'?';
    console.warn('SuperSonic failed at ['+failedAt+']:',e);
    if(sonic){try{sonic.shutdown();}catch(x){}}
    sonic=null;sonicReady=false;sonicLoading=false;
    if(badge){badge.textContent='Web Audio';badge.title='SuperSonic error: '+errMsg;badge.style.background='rgba(255,255,255,0.08)';badge.style.color='var(--text-dim)';}
    // Show error visually for debugging on mobile
    const errDiv=document.createElement('div');
    errDiv.style.cssText='position:fixed;bottom:0;left:0;right:0;background:#300;color:#f88;font:10px monospace;padding:4px 8px;z-index:9999;max-height:80px;overflow:auto;';
    errDiv.textContent='SS err: '+errMsg+' | step: '+failedAt+' | SAB:'+(typeof SharedArrayBuffer!=='undefined');
    document.body.appendChild(errDiv);
    setTimeout(()=>errDiv.remove(),30000);
  }
}

function freqToMidi(freq){return Math.round(12*Math.log2(freq/440)+69);}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SuperSonic FX â€” Web Audio delay + reverb on SS output
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let ssFxReverb=0.3, ssFxDelay=0, ssFxDelayTime=0.3;
let ssDelayNode=null, ssDelayFeedback=null, ssDelayWet=null, ssReverbGain=null, ssDryGain=null;
let ssConvolver=null, ssFxSetup=false;

function setupSSFxChain(){
  if(ssFxSetup||!sonic||!sonic.node)return;
  const ctx=sonic.node.context;
  if(!ctx)return;
  // Disconnect SuperSonic from default destination
  try{sonic.node.disconnect();}catch(e){}

  // Dry path
  ssDryGain=ctx.createGain();
  ssDryGain.gain.value=1-ssFxReverb;

  // Reverb path (convolver with impulse)
  ssConvolver=ctx.createConvolver();
  const len=ctx.sampleRate*2;
  const impulse=ctx.createBuffer(2,len,ctx.sampleRate);
  for(let ch=0;ch<2;ch++){
    const d=impulse.getChannelData(ch);
    for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/len,2.5);
  }
  ssConvolver.buffer=impulse;
  ssReverbGain=ctx.createGain();
  ssReverbGain.gain.value=ssFxReverb;

  // Delay path
  ssDelayNode=ctx.createDelay(2.0);
  ssDelayNode.delayTime.value=ssFxDelayTime;
  ssDelayFeedback=ctx.createGain();
  ssDelayFeedback.gain.value=0.4;
  ssDelayWet=ctx.createGain();
  ssDelayWet.gain.value=ssFxDelay;

  // Wiring: sonic.node â†’ dry â†’ destination
  //         sonic.node â†’ convolver â†’ reverbGain â†’ destination
  //         sonic.node â†’ delay â†’ feedback â†’ delay (loop)
  //                       delay â†’ delayWet â†’ destination
  sonic.node.connect(ssDryGain);
  ssDryGain.connect(ctx.destination);

  sonic.node.connect(ssConvolver);
  ssConvolver.connect(ssReverbGain);
  ssReverbGain.connect(ctx.destination);

  sonic.node.connect(ssDelayNode);
  ssDelayNode.connect(ssDelayFeedback);
  ssDelayFeedback.connect(ssDelayNode);
  ssDelayNode.connect(ssDelayWet);
  ssDelayWet.connect(ctx.destination);

  ssFxSetup=true;
}

function setSSReverb(v){
  ssFxReverb=v/100;
  document.getElementById('ssReverbVal').textContent=v+'%';
  if(ssReverbGain)ssReverbGain.gain.value=ssFxReverb;
  if(ssDryGain)ssDryGain.gain.value=Math.max(0,1-ssFxReverb*0.5);
}
function setSSDelay(v){
  ssFxDelay=v/100;
  document.getElementById('ssDelayVal').textContent=v>0?v+'%':'Off';
  if(ssDelayWet)ssDelayWet.gain.value=ssFxDelay;
}
function setSSDelayTime(v){
  ssFxDelayTime=v/1000;
  document.getElementById('ssDelayTimeVal').textContent=v+'ms';
  if(ssDelayNode)ssDelayNode.delayTime.value=ssFxDelayTime;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEB AUDIO â€” Fallback Synth
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let audioCtx=null,masterGain=null,reverbNode=null,activeVoices=[];

function getAudio(){
  if(!audioCtx){
    audioCtx=new(window.AudioContext||window.webkitAudioContext)();
    masterGain=audioCtx.createGain();
    masterGain.gain.value=0.35;
    try{
      reverbNode=audioCtx.createConvolver();
      const len=audioCtx.sampleRate*1.5;
      const impulse=audioCtx.createBuffer(2,len,audioCtx.sampleRate);
      for(let ch=0;ch<2;ch++){const d=impulse.getChannelData(ch);for(let i=0;i<len;i++)d[i]=(Math.random()*2-1)*Math.pow(1-i/len,2.5);}
      reverbNode.buffer=impulse;
      const wetGain=audioCtx.createGain();wetGain.gain.value=0.15;
      const dryGain=audioCtx.createGain();dryGain.gain.value=0.85;
      masterGain.connect(dryGain).connect(audioCtx.destination);
      masterGain.connect(reverbNode).connect(wetGain).connect(audioCtx.destination);
    }catch(e){masterGain.connect(audioCtx.destination);}
  }
  return audioCtx;
}
// Resume audio after tab switch â€” needs user gesture on iOS
let audioNeedsRestart=false;
document.addEventListener('visibilitychange',()=>{
  if(document.visibilityState==='hidden'&&audioCtx){
    audioNeedsRestart=true;
  }
});
function resumeAudioCtx(){
  if(!audioCtx)return;
  if(audioCtx.state==='suspended'){
    audioCtx.resume().catch(()=>{});
  }
  // If returning from background, force recreate audio + SuperSonic
  if(audioNeedsRestart){
    audioNeedsRestart=false;
    // Always tear down and rebuild â€” iOS kills WASM AudioWorklet nodes
    // even when ctx.state reports 'running' after resume
    sonic=null;sonicReady=false;sonicLoading=false;
    try{audioCtx.close();}catch(e){}
    audioCtx=null;masterGain=null;reverbNode=null;
    getAudio();
    initSuperSonic();
  }
}
// Pre-create AudioContext on first user gesture + boot SuperSonic
function ensureAudioReady(e){
  getAudio();
  resumeAudioCtx();
  // Boot SuperSonic on first gesture (async, non-blocking)
  if(!sonic&&!sonicLoading)initSuperSonic();
}
['touchstart','pointerdown'].forEach(evt=>{
  document.addEventListener(evt,ensureAudioReady,{passive:true,once:false});
});

function checkMuteState(){} // removed - was causing UI issues

// Apply voicing mode to intervals
function applyVoicing(intervals){
  let v=[...intervals];
  if(voicingMode==='open'&&v.length>=3){
    // Raise middle notes up an octave
    for(let i=1;i<v.length-1;i++) v[i]+=12;
  }else if(voicingMode==='spread'&&v.length>=3){
    // Spread across 2 octaves
    v=v.map((n,i)=>n+Math.floor(i*24/(v.length-1||1))-Math.floor(i*12/(v.length-1||1)));
  }
  return v;
}

// â”€â”€ Voice Management â”€â”€
const MAX_ACCOMP_VOICES=12; // limit simultaneous accompaniment voices
let accompVoices=[]; // separate tracking for accompaniment

function cleanupExpiredVoices(){
  if(!audioCtx)return;
  const now=audioCtx.currentTime;
  accompVoices=accompVoices.filter(v=>{
    if(now>v.endTime+0.1){
      try{v.oscs.forEach(o=>o.disconnect());v.gain.disconnect();v.filter.disconnect();}catch(e){}
      return false;
    }
    return true;
  });
}

// Play a single note with the synth engine
function playNote(ctx,freq,startTime,noteGain,duration,presetOverride){
  // â”€â”€ SuperSonic path â”€â”€
  if(sonicReady&&sonic&&!window._useWebAudio){
    // Ensure SuperSonic's AudioContext is running (iOS suspends it)
    if(sonic.node?.context?.state==='suspended') sonic.node.context.resume().catch(()=>{});
    const usedPreset=presetOverride||synthPreset;
    const synthName=SONIC_SYNTH_MAP[usedPreset]||'sonic-pi-prophet';
    const midiNote=freqToMidi(freq);
    const amp=Math.min(1,Math.max(0,noteGain*3)); // scale up from Web Audio gain range
    const attack=0.01;
    const sustain=Math.max(0.05,duration*0.6);
    const release=Math.max(0.1,duration*0.4);
    const cutoff=usedPreset==='bright'?110:usedPreset==='pad'?70:usedPreset==='pluck'?120:90;
    sonic.send('/s_new',synthName,-1,0,0,
      'note',midiNote,'amp',amp,'attack',attack,
      'sustain',sustain,'release',release,'cutoff',cutoff);
    return;
  }

  // â”€â”€ Web Audio fallback â”€â”€
  const usedPreset=presetOverride||synthPreset;
  const p=SYNTH_PRESETS[usedPreset]||SYNTH_PRESETS.warm;
  const isAccomp=!!presetOverride;
  
  // For accompaniment: use lightweight single-oscillator synth to reduce node count
  if(isAccomp){
    cleanupExpiredVoices();
    // If at voice limit, steal oldest voice
    if(accompVoices.length>=MAX_ACCOMP_VOICES){
      const old=accompVoices.shift();
      try{
        const now=ctx.currentTime;
        old.gain.gain.cancelScheduledValues(now);
        old.gain.gain.setValueAtTime(old.gain.gain.value,now);
        old.gain.gain.exponentialRampToValueAtTime(0.001,now+0.02);
        old.oscs.forEach(o=>{try{o.stop(now+0.03)}catch(e){}});
      }catch(e){}
    }
    
    const attack=Math.max(0.02,p.attack);
    const release=Math.min(Math.max(0.08,p.release),duration*0.5);
    const total=duration;
    const endTime=startTime+total;
    
    // Single oscillator + simple gain envelope (no filter for perf)
    const vGain=ctx.createGain();
    vGain.gain.setValueAtTime(0.001,startTime);
    vGain.gain.linearRampToValueAtTime(noteGain,startTime+attack);
    vGain.gain.linearRampToValueAtTime(noteGain*p.sustain,startTime+attack+p.decay);
    vGain.gain.setValueAtTime(noteGain*p.sustain,startTime+Math.max(0,total-release));
    vGain.gain.exponentialRampToValueAtTime(0.001,endTime);
    
    const osc=ctx.createOscillator();
    osc.type=p.osc==='sawtooth'?'triangle':p.osc; // triangle instead of saw for softer accomp
    osc.frequency.value=freq;
    osc.connect(vGain);
    vGain.connect(masterGain);
    osc.start(startTime);
    osc.stop(endTime+0.1);
    
    accompVoices.push({oscs:[osc],gain:vGain,filter:vGain,endTime});
    return;
  }
  
  // Full synth for chord notes (unchanged)
  const attack=p.attack;
  const release=Math.min(p.release,duration*0.5);
  const decay=p.decay,sustain=p.sustain;
  const total=duration;
  const vGain=ctx.createGain();
  vGain.gain.setValueAtTime(0.001,startTime);
  vGain.gain.linearRampToValueAtTime(noteGain,startTime+attack);
  vGain.gain.linearRampToValueAtTime(noteGain*sustain,startTime+attack+decay);
  vGain.gain.setValueAtTime(noteGain*sustain,startTime+Math.max(0,total-release));
  vGain.gain.exponentialRampToValueAtTime(0.001,startTime+total);
  const filter=ctx.createBiquadFilter();filter.type='lowpass';
  filter.frequency.setValueAtTime(p.filterStart,startTime);
  filter.frequency.exponentialRampToValueAtTime(p.filterEnd,startTime+total*0.7);
  filter.Q.value=p.filterQ;
  const oscs=[];
  const osc1=ctx.createOscillator();osc1.type=p.osc;osc1.frequency.value=freq;
  const m1=ctx.createGain();m1.gain.value=0.4;
  osc1.connect(m1);m1.connect(filter);oscs.push(osc1);
  if(p.detune>0){
    const osc2=ctx.createOscillator();osc2.type=p.osc;osc2.frequency.value=freq*(1+p.detune);
    const osc3=ctx.createOscillator();osc3.type=p.osc;osc3.frequency.value=freq*(1-p.detune);
    const m2=ctx.createGain();m2.gain.value=0.3;const m3=ctx.createGain();m3.gain.value=0.3;
    osc2.connect(m2);osc3.connect(m3);m2.connect(filter);m3.connect(filter);
    oscs.push(osc2,osc3);
  }
  if(p.sub){
    const sub=ctx.createOscillator();sub.type='triangle';sub.frequency.value=freq/2;
    const sg=ctx.createGain();sg.gain.value=p.subVol;
    sub.connect(sg);sg.connect(filter);oscs.push(sub);
  }
  if(usedPreset==='organ'){
    const h2=ctx.createOscillator();h2.type='sine';h2.frequency.value=freq*2;
    const h3=ctx.createOscillator();h3.type='sine';h3.frequency.value=freq*3;
    const hg2=ctx.createGain();hg2.gain.value=0.25;const hg3=ctx.createGain();hg3.gain.value=0.12;
    h2.connect(hg2);h3.connect(hg3);hg2.connect(filter);hg3.connect(filter);
    oscs.push(h2,h3);
  }
  filter.connect(vGain);vGain.connect(masterGain);
  oscs.forEach(o=>{o.start(startTime);o.stop(startTime+total+0.1);});
  activeVoices.push({gain:vGain,stop:(t)=>{oscs.forEach(o=>{try{o.stop(t)}catch(e){}})}});
}

function playChordNotes(rootNote,intervals){
  if(!soundOn)return;
  checkMuteState();
  // Force-recreate AudioContext if suspended (iOS kills it after tab switch/lock)
  let ctx=getAudio();
  if(ctx.state==='suspended'||ctx.state==='closed'){
    ctx.resume().catch(()=>{});
    // If still not running, nuke and recreate with silent warmup
    if(ctx.state!=='running'){
      try{ctx.close();}catch(e){}
      audioCtx=null;masterGain=null;reverbNode=null;
      ctx=getAudio();
      // Silent buffer warmup (iOS Safari unlock trick)
      try{const b=ctx.createBuffer(1,1,22050);const s=ctx.createBufferSource();s.buffer=b;s.connect(ctx.destination);s.start(0);}catch(e){}
      ctx.resume().catch(()=>{});
    }
  }
  const baseFreq=261.63*Math.pow(2,(rootNote+octaveShift*12)/12);
  const voiced=applyVoicing(intervals);
  const now=ctx.currentTime;
  // Only need to clean up Web Audio voices (SuperSonic self-releases)
  if(!sonicReady){
    activeVoices.forEach(v=>{try{v.gain.gain.cancelScheduledValues(now);v.gain.gain.setValueAtTime(v.gain.gain.value,now);v.gain.gain.exponentialRampToValueAtTime(0.001,now+0.05);v.stop(now+0.06);}catch(e){}});
    activeVoices=[];
  }
  const noteGain=0.12/voiced.length;
  const pTotal=(SYNTH_PRESETS[synthPreset]||SYNTH_PRESETS.warm).total;
  const total=phraseMode==='arpeggio'?pTotal*1.3:pTotal;
  // Play bass root note separately
  if(bassRoot){
    const bassFreq=baseFreq*Math.pow(2,-24/12); // 2 octaves down
    if(sonicReady&&sonic&&!window._useWebAudio){
      const bassMidi=freqToMidi(bassFreq);
      const bassDur=total+0.5;
      sonic.send('/s_new',SONIC_SYNTH_MAP[synthPreset]||'sonic-pi-prophet',-1,0,0,
        'note',bassMidi,'amp',0.25,'attack',0.01,'sustain',bassDur*0.6,'release',bassDur*0.4,'cutoff',70);
    }else{
      const bassGain=ctx.createGain();
      const bassAttack=0.01,bassDur=total+0.5;
      bassGain.gain.setValueAtTime(0.001,now);
      bassGain.gain.linearRampToValueAtTime(0.18,now+bassAttack);
      bassGain.gain.setValueAtTime(0.15,now+bassDur*0.6);
      bassGain.gain.exponentialRampToValueAtTime(0.001,now+bassDur);
      const bassOsc=ctx.createOscillator();bassOsc.type='sine';bassOsc.frequency.value=bassFreq;
      const bassOsc2=ctx.createOscillator();bassOsc2.type='triangle';bassOsc2.frequency.value=bassFreq;
      const mix1=ctx.createGain();mix1.gain.value=0.6;
      const mix2=ctx.createGain();mix2.gain.value=0.4;
      bassOsc.connect(mix1);bassOsc2.connect(mix2);
      mix1.connect(bassGain);mix2.connect(bassGain);
      bassGain.connect(masterGain);
      bassOsc.start(now);bassOsc.stop(now+bassDur+0.1);
      bassOsc2.start(now);bassOsc2.stop(now+bassDur+0.1);
      activeVoices.push({gain:bassGain,stop:(t)=>{try{bassOsc.stop(t);bassOsc2.stop(t);}catch(e){}}});
    }
  }
  // Play chord notes
  voiced.forEach((semi,i)=>{
    const freq=baseFreq*Math.pow(2,semi/12);
    const delay=phraseMode==='strum'?i*0.03:phraseMode==='arpeggio'?i*0.15:0;
    const dur=phraseMode==='arpeggio'?total-delay:total;
    playNote(ctx,freq,now+delay,noteGain,dur);
  });
}

function playChord(rootNote,quality){
  if(!soundOn)return;
  const intervals=QUALITY[quality]?.intervals||[0,4,7];
  playChordNotes(rootNote,intervals);
}

// Play chord with explicit interval array
function playChordIntervals(rootNote,intervals){
  playChordNotes(rootNote,intervals);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAGENTA.JS â€” AI IMPROVISATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let improvEnabled=false;
let improvPlaying=false;
let improvTimers=[];
// Improv settings
let improvTempo=140;
let improvSteps=64;
let improvTemperature=0.8;
let improvGain=0.03;
let improvOctave=-1;
let improvModel='vae'; // 'rnn' or 'vae'
let improvSynth='pad'; // synth preset for accompaniment (default different from chord)
let improvContinuous=true; // loop continuously
let _lastVAESequence=null; // last generated VAE sequence (for interpolation)
let _lastChordSym=null; // last chord symbol used
let _continuousChord=null; // {rootIdx, quality} for continuous loop

// Model instances (lazy-loaded)
let _improvRNN=null, _improvVAE=null, _improvLoading=false;

const CHECKPOINTS={
  rnn:'https://storage.googleapis.com/magentadata/js/checkpoints/music_rnn/chord_pitches_improv',
  vae:'https://storage.googleapis.com/magentadata/js/checkpoints/music_vae/mel_chords'
};

function showImprovLoading(show,text){
  const bar=document.getElementById('improvLoadingBar');
  const btn=document.getElementById('improvBtn');
  if(show){
    bar.classList.add('show');
    btn.classList.add('loading');
    if(text)document.getElementById('improvLoadingText').textContent=text;
  }else{
    bar.classList.remove('show');
    btn.classList.remove('loading');
  }
}

async function getImprovModel(){
  if(improvModel==='vae'){
    if(_improvVAE)return _improvVAE;
  }else{
    if(_improvRNN)return _improvRNN;
  }
  if(_improvLoading)return null;
  _improvLoading=true;
  const modelName=improvModel==='vae'?'MelodyVAE (17.6MB)':'ImprovRNN (5.6MB)';
  showImprovLoading(true,`Loading ${modelName}â€¦`);
  try{
    if(improvModel==='vae'){
      _improvVAE=new mm.MusicVAE(CHECKPOINTS.vae);
      await _improvVAE.initialize();
      _improvLoading=false;
      showImprovLoading(false);
      return _improvVAE;
    }else{
      _improvRNN=new mm.MusicRNN(CHECKPOINTS.rnn);
      await _improvRNN.initialize();
      _improvLoading=false;
      showImprovLoading(false);
      return _improvRNN;
    }
  }catch(e){
    console.error('Magenta init failed:',e);
    _improvLoading=false;
    showImprovLoading(false);
    return null;
  }
}

function toggleImprov(){
  const panel=document.getElementById('improvPanel');
  panel.classList.toggle('open');
  document.getElementById('voicePanel').classList.remove('open');
  document.getElementById('midiPanel').classList.remove('open');
}
function setImprovEnabled(v){
  improvEnabled=v;
  document.getElementById('improvBtn').classList.toggle('active',improvEnabled);
  if(improvEnabled){
    getImprovModel().then(m=>{
      if(!m){improvEnabled=false;document.getElementById('improvToggle').checked=false;}
      document.getElementById('improvBtn').classList.toggle('active',improvEnabled);
    });
  }
  if(!improvEnabled)stopImprov();
}
function setImprovModel(m){
  improvModel=m;
  document.querySelectorAll('[data-improv-model]').forEach(b=>b.classList.toggle('active',b.dataset.improvModel===m));
  if(improvEnabled)getImprovModel();
  // Reset last sequence when switching models
  _lastGeneratedSeq=null;
}
function setImprovContinuous(v){
  improvContinuous=v;
  if(!v){_continuousChord=null;}
}
function setImprovSynth(s){
  improvSynth=s;
  if(SONIC_PI_PRESETS.has(s)){
    if(!sonicReady&&!sonicLoading)initSuperSonic();
    window._useWebAudio=false;
    const badge=document.getElementById('engineBadge');
    if(badge){badge.textContent='âš¡ SuperSonic';badge.style.background='rgba(61,173,217,0.2)';badge.style.color='#3DADD9';}
  }
  document.querySelectorAll('[data-improv-synth]').forEach(b=>b.classList.toggle('active',b.dataset.improvSynth===s));
}
function setImprovTempo(v){improvTempo=+v;document.getElementById('improvTempoVal').textContent=v+'bpm';}
function setImprovSteps(v){improvSteps=+v;const labels={8:'Â½ bar',16:'1 bar',32:'2 bars',64:'4 bars'};document.getElementById('improvStepsVal').textContent=labels[v]||v+' steps';}
function setImprovTemp(v){improvTemperature=+v;const labels={'0.5':'Conservative','0.8':'Gentle','1.1':'Balanced','1.5':'Wild','2.0':'Chaotic'};document.getElementById('improvTempVal').textContent=labels[v]||v;}
function setImprovGain(v){improvGain=+v;document.getElementById('improvGainVal').textContent=Math.round(v*100)+'%';}
function setImprovOctave(d){improvOctave=Math.max(-2,Math.min(2,improvOctave+d));document.getElementById('improvOctLabel').textContent=improvOctave>0?'+'+improvOctave:improvOctave;}

function stopImprov(){
  improvPlaying=false;
  _continuousChord=null;
  stopScheduler();
  improvTimers.forEach(t=>clearTimeout(t));
  improvTimers=[];
}

// Convert chord name to Magenta-compatible chord symbol (e.g. "Cm", "F", "Dm7", "G7")
function chordToMagentaSymbol(rootIdx, quality){
  const name=noteName(rootIdx,true);
  const suffixMap={major:'',minor:'m',dim:'dim',aug:'aug',dom7:'7',maj7:'maj7',min7:'m7',halfdim:'m7b5'};
  return name+(suffixMap[quality]||'');
}

// Create a short seed sequence (one bar of quarter notes from the chord)
function makeSeedSequence(rootIdx, quality){
  const intervals=QUALITY[quality]?.intervals||[0,4,7];
  const baseNote=60+rootIdx; // MIDI note (C4=60)
  const pitches=intervals.map(i=>baseNote+i);
  // Pad to 4 notes by repeating octave-up root if needed
  while(pitches.length<4) pitches.push(pitches[0]+12);
  // Create unquantized NoteSequence, then quantize properly
  const qpm=120;
  const beatDur=60/qpm; // 0.5s per quarter at 120bpm
  const unquantized={
    ticksPerQuarter:220,
    totalTime: 4*beatDur,
    timeSignatures:[{time:0,numerator:4,denominator:4}],
    tempos:[{time:0,qpm:qpm}],
    notes: pitches.slice(0,4).map((pitch,i)=>({
      pitch: Math.min(83,Math.max(48,pitch)),
      startTime: i*beatDur,
      endTime: (i+1)*beatDur,
      instrument:0, program:0, velocity:100, isDrum:false
    }))
  };
  return mm.sequences.quantizeNoteSequence(unquantized, 4);
}

// â”€â”€ Lookahead Scheduler (sample-accurate timing) â”€â”€
// Based on Chris Wilson's "A Tale of Two Clocks" pattern.
// A JS interval runs frequently and schedules notes into Web Audio's
// future using ctx.currentTime, giving sample-accurate timing without
// setTimeout jitter.

const SCHED_LOOKAHEAD=0.1;  // seconds to look ahead
const SCHED_INTERVAL=25;    // ms between scheduler ticks

let _schedQueue=[];       // [{audioTime, freq, gain, dur, preset}]
let _schedTimer=null;
let _schedEndTime=0;      // audioTime when current sequence ends
let _schedOnEnd=null;     // callback when sequence finishes
let _schedStartTime=0;    // audioTime when current sequence started

function startScheduler(){
  if(_schedTimer)return;
  _schedTimer=setInterval(schedulerTick,SCHED_INTERVAL);
}

function stopScheduler(){
  if(_schedTimer){clearInterval(_schedTimer);_schedTimer=null;}
  _schedQueue=[];
  _schedOnEnd=null;
}

function schedulerTick(){
  const ctx=audioCtx;
  if(!ctx||!improvPlaying){stopScheduler();return;}
  const now=ctx.currentTime;
  const horizon=now+SCHED_LOOKAHEAD;
  
  // Schedule any notes within the lookahead window
  while(_schedQueue.length>0&&_schedQueue[0].audioTime<=horizon){
    const n=_schedQueue.shift();
    if(n.audioTime<now-0.05)continue; // skip notes too far in the past
    playNote(ctx,n.freq,Math.max(now,n.audioTime),n.gain,n.dur,n.preset);
  }
  
  // Check if sequence has ended
  if(_schedQueue.length===0&&now>=_schedEndTime-0.05){
    const cb=_schedOnEnd;
    _schedOnEnd=null;
    stopScheduler();
    if(cb)cb();
  }
}

// Queue a NoteSequence for sample-accurate playback
// startAtAudioTime: the ctx.currentTime at which beat 0 should play
function scheduleSequence(result, startAtAudioTime, onEnd){
  const ctx=getAudio();
  if(!ctx){if(onEnd)onEnd();return;}
  
  const bpm=improvTempo;
  const stepDur=60/(bpm*4); // duration of one step (16th note)
  const baseTime=startAtAudioTime||ctx.currentTime;
  
  // Build sorted queue of notes
  const notes=[];
  result.notes.forEach(note=>{
    const audioTime=baseTime+(note.quantizedStartStep*stepDur);
    const dur=Math.max(0.1,(note.quantizedEndStep-note.quantizedStartStep)*stepDur);
    const shiftedPitch=note.pitch+(improvOctave*12);
    const freq=440*Math.pow(2,(shiftedPitch-69)/12);
    notes.push({audioTime, freq, gain:improvGain, dur, preset:improvSynth});
  });
  notes.sort((a,b)=>a.audioTime-b.audioTime);
  
  _schedQueue=notes;
  _schedEndTime=baseTime+(result.totalQuantizedSteps*stepDur);
  _schedOnEnd=onEnd;
  _schedStartTime=baseTime;
  startScheduler();
  
  // Return the end time so continuous mode can pre-schedule the next phrase
  return _schedEndTime;
}

// Legacy wrapper for non-scheduler callers
function playImprovSequence(result, onEnd){
  const ctx=getAudio();
  if(!ctx){if(onEnd)onEnd();return;}
  scheduleSequence(result, ctx.currentTime, onEnd);
}

// Generate an improv sequence using whichever model is selected
let _lastGeneratedSeq=null; // last output for seeding next RNN phrase

async function generateImprovSequence(model, chordSym, temperature, rootIdx, quality){
  if(improvModel==='vae'){
    // MusicVAE mel_chords: always generates 2 bars (32 steps)
    // Just sample cleanly â€” chord conditioning does the work
    const controlArgs={chordProgression:[chordSym,chordSym]};
    const samples=await model.sample(1, temperature, controlArgs);
    _lastGeneratedSeq=samples[0];
    return samples[0];
  }else{
    // MusicRNN: use end of last phrase as seed for continuity, or create fresh seed
    let seed;
    if(_lastGeneratedSeq&&_lastGeneratedSeq.notes&&_lastGeneratedSeq.notes.length>=4){
      // Take last 4 notes of previous phrase as seed
      const lastNotes=_lastGeneratedSeq.notes.slice(-4);
      const minStep=lastNotes[0].quantizedStartStep;
      const reseeded={
        notes:lastNotes.map((n,i)=>({
          pitch:n.pitch,
          quantizedStartStep:i,
          quantizedEndStep:i+1,
        })),
        quantizationInfo:{stepsPerQuarter:4},
        totalQuantizedSteps:lastNotes.length,
      };
      seed=reseeded;
    }else{
      seed=makeSeedSequence(rootIdx,quality);
    }
    const stepsToGen=improvSteps;
    const chordProg=Array(Math.ceil(stepsToGen/16)).fill(chordSym);
    const result=await model.continueSequence(seed, stepsToGen, temperature, chordProg);
    _lastGeneratedSeq=result;
    return result;
  }
}

// Continuous loop for VAE â€” pre-generates next phrase during current playback
let _nextPhraseReady=null; // pre-generated next phrase
let _pregenInProgress=false;

async function pregenNextPhrase(){
  if(_pregenInProgress||!improvPlaying||!improvContinuous||!_continuousChord)return;
  _pregenInProgress=true;
  try{
    const model=await getImprovModel();
    if(!model||!improvPlaying||!improvContinuous){_pregenInProgress=false;return;}
    const{rootIdx,quality}=_continuousChord;
    const chordSym=chordToMagentaSymbol(rootIdx,quality);
    _nextPhraseReady=await generateImprovSequence(model, chordSym, improvTemperature, rootIdx, quality);
  }catch(e){
    console.warn('Pre-gen failed:',e);
    _nextPhraseReady=null;
  }
  _pregenInProgress=false;
}

async function continuousLoop(){
  if(!improvPlaying||!improvContinuous||!_continuousChord)return;
  
  let result=_nextPhraseReady;
  _nextPhraseReady=null;
  
  if(!result){
    // No pre-generated phrase ready, generate now
    const model=await getImprovModel();
    if(!model){improvPlaying=false;return;}
    const{rootIdx,quality}=_continuousChord;
    const chordSym=chordToMagentaSymbol(rootIdx,quality);
    try{
      result=await generateImprovSequence(model, chordSym, improvTemperature, rootIdx, quality);
    }catch(e){
      console.error('Continuous loop failed:',e);
      improvPlaying=false;return;
    }
  }
  
  if(!improvPlaying||!improvContinuous)return;
  
  // Schedule this phrase; get its end time for seamless next phrase
  const ctx=getAudio();
  if(!ctx)return;
  const endTime=scheduleSequence(result, _schedEndTime||ctx.currentTime, ()=>{
    if(improvPlaying&&improvContinuous)continuousLoop();
    else improvPlaying=false;
  });
  
  // Start pre-generating the next phrase immediately
  pregenNextPhrase();
}

// Generate and play an improvisation over a chord
async function improviseOverChord(rootIdx, quality, playChordFn){
  if(!improvEnabled||!soundOn)return;
  stopImprov();
  const model=await getImprovModel();
  if(!model){if(playChordFn)playChordFn();return;}
  
  improvPlaying=true;
  _continuousChord={rootIdx,quality};
  const chordSym=chordToMagentaSymbol(rootIdx,quality);
  
  try{
    let result;
    const temperature=improvTemperature;
    showImprovLoading(true,'Generating melodyâ€¦');
    
    result=await generateImprovSequence(model, chordSym, temperature, rootIdx, quality);
    showImprovLoading(false);
    
    if(!improvPlaying){if(playChordFn)playChordFn();return;}
    
    // Play chord and improv at the same instant
    if(playChordFn)playChordFn();
    
    // Clear pre-gen and reset seed on chord change
    _nextPhraseReady=null;
    _lastGeneratedSeq=null;
    
    const ctx=getAudio();
    const startTime=ctx?ctx.currentTime:0;
    scheduleSequence(result, startTime, ()=>{
      if(improvContinuous&&improvPlaying){
        continuousLoop();
      }else{
        improvPlaying=false;
      }
    });
    
    // Pre-generate next phrase while this one plays
    if(improvContinuous)pregenNextPhrase();
  }catch(e){
    console.error('Improv generation failed:',e);
    improvPlaying=false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let currentRoot=0;
let currentMode='diatonic';
let currentScale='major'; // major, minor, diminished, lydian
const SCALE_TYPES=['major','minor','diminished','lydian'];
let history_stack=[{root:0,name:'C'}];
let redoStack=[];
let selectedPetal=-1;
let showNames=true;
let soundOn=true;
let lockRoot=false;
// Voicing & phrasing options
let bassRoot=false;      // play root in bass octave
let voicingMode='close'; // close, open, spread
let phraseMode='block';  // block, strum, arpeggio
let octaveShift=0;       // -2 to +2 octaves
let synthPreset='warm';  // warm, bright, pad, keys, pluck, organ
const SYNTH_PRESETS={
  warm:{osc:'sawtooth',detune:0.005,sub:true,subVol:0.3,filterStart:2200,filterEnd:800,filterQ:1.5,attack:0.005,decay:0.12,sustain:0.6,release:1.0,total:1.8},
  bright:{osc:'sawtooth',detune:0.008,sub:false,subVol:0,filterStart:6000,filterEnd:2000,filterQ:2.0,attack:0.003,decay:0.08,sustain:0.7,release:0.8,total:1.5},
  pad:{osc:'sine',detune:0.003,sub:true,subVol:0.5,filterStart:1500,filterEnd:600,filterQ:0.8,attack:0.15,decay:0.3,sustain:0.8,release:1.5,total:3.0},
  keys:{osc:'triangle',detune:0.002,sub:false,subVol:0,filterStart:4000,filterEnd:500,filterQ:1.0,attack:0.002,decay:0.25,sustain:0.3,release:0.5,total:1.2},
  pluck:{osc:'sawtooth',detune:0.01,sub:false,subVol:0,filterStart:8000,filterEnd:300,filterQ:3.0,attack:0.001,decay:0.04,sustain:0.1,release:0.3,total:0.6},
  organ:{osc:'sine',detune:0,sub:true,subVol:0.6,filterStart:3000,filterEnd:2800,filterQ:0.5,attack:0.003,decay:0.04,sustain:0.9,release:0.2,total:2.0},
};
const VOICING_MODES=['close','open','spread'];
const PHRASE_MODES=['block','strum','arpeggio'];
let petalCount=5; // default visible petals
let globalRotation=0; // degrees offset from dragging outer ring

// Debug layout params (controlled by sliders)
var dbgMinGap=3;          // padding between circles
var dbgPetalScale=0.9;    // petal size multiplier
var dbgSpread=0.55;       // orbit distance multiplier
var dbgOverlap=0.24;      // petal overlap (0=none, 1=full)
var dbgRingOffset=0.5;    // angle offset per ring (fraction of petal angle step)
var dbgVertCenter=0.38;   // vertical center position (0-1)
let petalElements=[];
let petalCustomOffsets={}; // index -> {dx,dy} for dragged petals
let petalVoicings={}; // index -> 0-3 (ring level: triad, 7th, 9th, 11th)
let subPetals=[]; // array of {parentIdx, voiceLevel} â€” voiceLevel: 1=7th, 2=9th, 3=11th
let subPetalElements=[];
let nextSubParent=0; // which inner petal gets the next sub-petal
// Cached garden dimensions
let _gardenW=360,_gardenH=360;
function cacheGardenDims(){const g=document.getElementById('garden');_gardenW=g.clientWidth||360;_gardenH=g.clientHeight||360;}

function init(){
  const bar=document.getElementById('modeBar');
  MODES.forEach(m=>{
    const btn=document.createElement('button');
    btn.className='mode-btn'+(m.id===currentMode?' active':'');
    btn.textContent=m.label;
    btn.onclick=()=>setMode(m.id);
    btn.dataset.mode=m.id;
    bar.appendChild(btn);
  });
  buildKeyPopup();
  buildMidiChannels();
  render();
  initDragSystem();
}

function setMode(id){
  currentMode=id;
  document.querySelectorAll('.mode-btn').forEach(b=>b.classList.toggle('active',b.dataset.mode===id));
  petalCustomOffsets={};subPetals=[];nextSubParent=0;
  render();
}

function setRoot(noteIdx,name){
  redoStack=[];
  history_stack.push({root:noteIdx,name});
  if(history_stack.length>12)history_stack=history_stack.slice(-12);
  currentRoot=noteIdx;
  petalCustomOffsets={};subPetals=[];nextSubParent=0;
  selectedPetal=-1;
  render();
}

function undoHistory(){
  if(history_stack.length<=1)return;
  redoStack.push(history_stack.pop());
  const prev=history_stack[history_stack.length-1];
  currentRoot=prev.root;
  petalCustomOffsets={};selectedPetal=-1;
  render();
}
function redoHistory(){
  if(!redoStack.length)return;
  const next=redoStack.pop();
  history_stack.push(next);
  currentRoot=next.root;
  petalCustomOffsets={};selectedPetal=-1;
  render();
}

// Toolbar toggles
function toggleNames(){showNames=!showNames;document.getElementById('eyeBtn').classList.toggle('active',showNames);render();}
function toggleSound(){
  soundOn=!soundOn;
  document.getElementById('soundBtn').classList.toggle('active',soundOn);
  document.getElementById('soundBtn').textContent=soundOn?'ğŸ”Š':'ğŸ”‡';
  if(soundOn){
    // Nuke and recreate AudioContext to avoid stale/suspended state
    if(audioCtx){try{audioCtx.close();}catch(e){}}
    audioCtx=null;masterGain=null;reverbNode=null;activeVoices=[];
    const ctx=getAudio();
    // Warm up: play silent buffer to unlock iOS Safari audio
    try{
      const buf=ctx.createBuffer(1,1,22050);
      const src=ctx.createBufferSource();
      src.buffer=buf;src.connect(ctx.destination);src.start(0);
    }catch(e){}
    ctx.resume().catch(()=>{});
  }else{
    // Muting: stop all active voices and suspend context
    activeVoices.forEach(v=>{try{v.stop(0);}catch(e){}});
    activeVoices=[];
    if(audioCtx)audioCtx.suspend().catch(()=>{});
  }
}
function toggleLock(){lockRoot=!lockRoot;document.getElementById('lockBtn').classList.toggle('active',lockRoot);document.getElementById('lockBtn').textContent=lockRoot?'ğŸ”’':'ğŸ”“';}
function copyChords(){
  const mode=MODES.find(m=>m.id===currentMode);
  const chords=mode.fn(currentRoot).slice(0,petalCount);
  const txt=chords.map(c=>c.name).join(' - ');
  navigator.clipboard?.writeText(txt);
}

function addPetal(){
  petalCount=Math.min(12,petalCount+1);
  document.getElementById('petalCountLabel').textContent=petalCount;
  render();
}
function removePetal(){
  petalCount=Math.max(3,petalCount-1);
  if(selectedPetal>=petalCount)selectedPetal=-1;
  // Remove any sub-petals whose parent is gone
  subPetals=subPetals.filter(sp=>sp.parentIdx<petalCount);
  document.getElementById('petalCountLabel').textContent=petalCount;
  render();
}
function addSubPetal(){
  // Add an alternate voicing to the last tapped petal (or round-robin if none selected)
  let tried=0;
  while(tried<petalCount){
    const parentIdx=selectedPetal>=0&&selectedPetal<petalCount&&tried===0?selectedPetal:nextSubParent%petalCount;
    const mode=MODES.find(m=>m.id===currentMode);
    const allChords=mode.fn(currentRoot);
    const parentChord=allChords[parentIdx];
    if(!parentChord){nextSubParent=(parentIdx+1)%petalCount;tried++;continue;}
    
    // Determine note count from parent's current voicing level
    const parentVL=petalVoicings[parentIdx]||0;
    const ext=VOICING_EXTENSIONS[parentChord.quality];
    const baseIntervals=ext?ext[parentVL]:QUALITY[parentChord.quality]?.intervals||[0,4,7];
    const noteCount=baseIntervals.length;
    
    // Get available alternate voicings for this quality + note count
    const alts=getAltVoicings(parentChord.quality,noteCount);
    if(!alts){nextSubParent=(parentIdx+1)%petalCount;tried++;continue;}
    
    // Find next unused voicing (skip root position = index 0)
    const existing=subPetals.filter(sp=>sp.parentIdx===parentIdx);
    const nextAltIdx=existing.length+1; // 0=root(parent), 1+=alternates
    if(nextAltIdx>=alts.length){
      nextSubParent=(parentIdx+1)%petalCount;tried++;continue;
    }
    
    const alt=alts[nextAltIdx];
    subPetals.push({parentIdx, voiceLevel:parentVL, altIdx:nextAltIdx, altName:alt.name, altIntervals:alt.intervals});
    nextSubParent=(parentIdx+1)%petalCount;
    render();
    // Preview the voicing
    playChordIntervals(parentChord.root, alt.intervals);
    return;
  }
}

// Key selector popup
function buildKeyPopup(){
  const popup=document.getElementById('keyPopup');
  NOTES.forEach((n,i)=>{
    const btn=document.createElement('button');
    btn.textContent=noteName(i,true);
    btn.onclick=(e)=>{e.stopPropagation();popup.classList.remove('show');setRoot(i,noteName(i,true));};
    popup.appendChild(btn);
  });
}
function showKeyPopup(){
  const popup=document.getElementById('keyPopup');
  popup.querySelectorAll('button').forEach((b,i)=>b.classList.toggle('current',i===currentRoot));
  popup.classList.add('show');
}

// Swipe up/down on center to change scale
let centerTouchStartY=null;
document.getElementById('center').addEventListener('touchstart',(e)=>{
  centerTouchStartY=e.touches[0].clientY;
},{passive:true});
document.getElementById('center').addEventListener('touchend',(e)=>{
  if(centerTouchStartY===null)return;
  const dy=e.changedTouches[0].clientY-centerTouchStartY;
  centerTouchStartY=null;
  if(Math.abs(dy)<30){
    // Tap â€” play chord immediately (don't rely on click event)
    e.preventDefault();e.stopPropagation();
    playChord(currentRoot,'major');
    sendMIDIChord(currentRoot,'major');
    const el=document.getElementById('center');
    el.style.transform='translate(-50%,-50%) scale(1.08)';
    setTimeout(()=>el.style.transform='translate(-50%,-50%)',150);
    return;
  }
  e.preventDefault();e.stopPropagation();
  const idx=SCALE_TYPES.indexOf(currentScale);
  if(dy<0){// swipe up = next
    currentScale=SCALE_TYPES[(idx+1)%SCALE_TYPES.length];
  }else{// swipe down = prev
    currentScale=SCALE_TYPES[(idx-1+SCALE_TYPES.length)%SCALE_TYPES.length];
  }
  petalCustomOffsets={};selectedPetal=-1;
  render();
});
// Mouse wheel on center also changes scale (desktop)
document.getElementById('center').addEventListener('wheel',(e)=>{
  e.preventDefault();
  const idx=SCALE_TYPES.indexOf(currentScale);
  currentScale=SCALE_TYPES[(idx+(e.deltaY>0?1:-1)+SCALE_TYPES.length)%SCALE_TYPES.length];
  petalCustomOffsets={};selectedPetal=-1;
  cacheGardenDims();render();
},{passive:false});

// Center click â€” play chord only
document.getElementById('center').addEventListener('click',(e)=>{
  e.stopPropagation();
  playChord(currentRoot,'major');
  sendMIDIChord(currentRoot,'major');
  const el=document.getElementById('center');
  el.style.transform='translate(-50%,-50%) scale(1.08)';
  setTimeout(()=>el.style.transform='translate(-50%,-50%)',150);
});
// Long-press center to show key selector
let centerLongPressT=null;
document.getElementById('center').addEventListener('pointerdown',(e)=>{
  centerLongPressT=setTimeout(()=>{showKeyPopup();centerLongPressT=null;},500);
});
document.getElementById('center').addEventListener('pointerup',()=>{if(centerLongPressT)clearTimeout(centerLongPressT);});
document.getElementById('center').addEventListener('pointermove',()=>{if(centerLongPressT)clearTimeout(centerLongPressT);});
// Close key popup on outside click
document.addEventListener('click',(e)=>{
  if(e.target.closest('.key-popup')||e.target.closest('.center-chord'))return;
  document.getElementById('keyPopup').classList.remove('show');
});

// Tap empty space in garden to add a petal
function gardenEmptyTap(e){
  if(e.target.closest('.petal')||e.target.closest('.center-chord')||e.target.closest('.rotation-ring')||e.target.closest('.key-popup')||e.target.closest('.petal-count')||e.target.closest('.delete-ring')||e.target.closest('.midi-panel')||e.target.closest('#voicePanel')||e.target.closest('#improvPanel')||e.target.closest('#debugPanel')||e.target.closest('.tool-btn')||e.target.closest('.toolbar'))return;
  // Don't add petal if we just closed a panel
  const midiPanel=document.getElementById('midiPanel');
  const voicePanel=document.getElementById('voicePanel');
  const improvPanel=document.getElementById('improvPanel');
  if(midiPanel._justClosed||voicePanel._justClosed||improvPanel._justClosed){delete midiPanel._justClosed;delete voicePanel._justClosed;delete improvPanel._justClosed;return;}
  // Top half: add main petal, Bottom half: add voicing sub-petal
  const garden=document.getElementById('garden');
  const rect=garden.getBoundingClientRect();
  const tapY=e.clientY-rect.top;
  if(tapY<rect.height*0.5){addPetal();return;}
  addSubPetal();
}
document.getElementById('garden').addEventListener('click',gardenEmptyTap);

function render(){
  const mode=MODES.find(m=>m.id===currentMode);
  let allChords=mode.fn(currentRoot);
  while(allChords.length<petalCount){
    const next=(currentRoot+allChords.length)%12;
    allChords.push(chord(next,'major','+'));
  }
  const chords=allChords.slice(0,petalCount);
  const rootName=noteName(currentRoot,true);

  document.getElementById('centerName').textContent=rootName;
  document.getElementById('centerSub').textContent=currentScale;
  document.getElementById('undoBtn').disabled=history_stack.length<=1;
  document.getElementById('redoBtn').disabled=redoStack.length===0;

  const garden=document.getElementById('garden');
  const gw=_gardenW,gh=_gardenH;
  let cx=gw/2, cy=gh*dbgVertCenter;
  const scale=Math.min(gw,gh)/300;
  const centerR=Math.round(48*scale), petalR=Math.round(36*scale);

  const cEl=document.getElementById('center');
  cEl.style.width=(centerR*2)+'px';cEl.style.height=(centerR*2)+'px';
  document.getElementById('centerName').style.fontSize=Math.round(centerR*0.55)+'px';
  document.getElementById('centerSub').style.fontSize=Math.round(centerR*0.2)+'px';
  // â”€â”€ Radial ring layout â”€â”€
  // Concentric rings around center with angle offset per ring
  const pR=petalR*dbgPetalScale;
  const spread=dbgSpread; // orbit distance multiplier
  const overlap=dbgOverlap; // how much petals can overlap (0=none, 1=full)
  const rotRad=globalRotation*Math.PI/180;
  
  // Calculate how many fit per ring based on orbit radius
  const ringGap=pR*2*(1-overlap)+dbgMinGap; // effective diameter with overlap
  const orbitR1=centerR+pR*spread; // first ring orbit
  
  // Distribute petals into rings
  const packPositions=[];
  let remaining=chords.length;
  let ringIdx=0;
  let placed=0;
  while(remaining>0){
    const orbitR=orbitR1+ringIdx*ringGap*spread;
    // How many circles fit on this ring? circumference / effective diameter
    const maxFit=ringIdx===0?Math.max(1,Math.floor(Math.PI*2*orbitR/ringGap)):
                              Math.max(1,Math.floor(Math.PI*2*orbitR/ringGap));
    const count=Math.min(maxFit,remaining);
    const angleStep=2*Math.PI/count;
    const offset=ringIdx*angleStep*dbgRingOffset+rotRad;
    
    for(let i=0;i<count;i++){
      const angle=angleStep*i-Math.PI/2+offset; // start at top
      packPositions.push({x:orbitR*Math.cos(angle),y:orbitR*Math.sin(angle)});
    }
    remaining-=count;
    placed+=count;
    ringIdx++;
    if(ringIdx>10)break; // safety
  }
  
  // Outermost petal distance for ring sizing
  let outerOrbitR=centerR+pR;
  // Compute bounding box of all positions to center the cluster vertically
  let minY=-centerR, maxY=centerR, minX=-centerR, maxX=centerR;
  for(const p of packPositions){
    const d=Math.sqrt(p.x*p.x+p.y*p.y);
    if(d>outerOrbitR)outerOrbitR=d;
    minY=Math.min(minY,p.y-pR);maxY=Math.max(maxY,p.y+pR);
    minX=Math.min(minX,p.x-pR);maxX=Math.max(maxX,p.x+pR);
  }
  // Shift center so flower cluster is centered in garden
  const clusterMidY=(minY+maxY)/2;
  const clusterMidX=(minX+maxX)/2;
  cy-=clusterMidY; // shift to vertically center
  cx-=clusterMidX; // shift to horizontally center

  // Position center element using adjusted cx/cy
  cEl.style.left=cx+'px';cEl.style.top=cy+'px';

  const ring=document.getElementById('rotRing');
  const ringR=outerOrbitR+pR+14;
  ring.style.width=ring.style.height=(ringR*2)+'px';
  ring.style.left=(cx-ringR)+'px';ring.style.top=(cy-ringR)+'px';

  const delRing=document.getElementById('deleteRing');
  delRing.style.width=delRing.style.height=(ringR*2)+'px';
  delRing.style.left=(cx-ringR)+'px';delRing.style.top=(cy-ringR)+'px';

  // DOM recycling: reuse existing petal elements
  const needed=chords.length;
  // Remove excess
  while(petalElements.length>needed){
    const el=petalElements.pop();el.remove();
  }
  // Add missing
  while(petalElements.length<needed){
    const el=document.createElement('div');
    el.className='petal';
    el.style.boxShadow='none';
    garden.appendChild(el);
    petalElements.push(el);
  }

  // Scale down petals when there are many
  const petalScale=(chords.length>7?Math.max(0.6,1-(chords.length-7)*0.04):1)*dbgPetalScale;
  const pDiam=Math.round(petalR*2*petalScale);

  chords.forEach((ch,i)=>{
    const pp=packPositions[i]||{x:0,y:0};
    const custom=petalCustomOffsets[i];
    const px=custom?cx+custom.dx:cx+pp.x;
    const py=custom?cy+custom.dy:cy+pp.y;
    const qi=QUALITY[ch.quality]||QUALITY.major;
    const voiceLevel=petalVoicings[i]||0;

    const el=petalElements[i];
    // Use transform for GPU-accelerated positioning
    el.style.transform=`translate(${px-pDiam/2}px,${py-pDiam/2}px)`;
    el.style.width=pDiam+'px';el.style.height=pDiam+'px';
    el.style.left='0';el.style.top='0';
    el.style.background=qi.solid;
    el.classList.toggle('selected',i===selectedPetal);
    el.dataset.index=i;
    // Store chord data for event handlers
    el._chordData={ch,i,voiceLevel};
    el._basePos={x:px-pDiam/2,y:py-pDiam/2};

    // Build innerHTML only if content changed
    // Build voicing rings as filled circles with progressively darker HSV value
    let ringsHTML='';
    if(voiceLevel>0){
      const half=pDiam/2;
      // Parse the petal's solid color to HSL, then darken V by 5% per ring
      const solidColor=qi.solid;
      ringsHTML=`<svg class="petal-rings" viewBox="0 0 ${pDiam} ${pDiam}" width="${pDiam}" height="${pDiam}">`;
      // Convert hex to HSL, decrease L by 5% per ring
      const hexMatch=solidColor.match(/#([0-9a-f]{6})/i);
      let h=0,s=0,l=50;
      if(hexMatch){
        let R=parseInt(hexMatch[1].slice(0,2),16)/255;
        let G=parseInt(hexMatch[1].slice(2,4),16)/255;
        let B=parseInt(hexMatch[1].slice(4,6),16)/255;
        const max=Math.max(R,G,B),min=Math.min(R,G,B);
        l=(max+min)/2;
        if(max!==min){
          const d=max-min;
          s=l>0.5?d/(2-max-min):d/(max+min);
          if(max===R)h=((G-B)/d+(G<B?6:0))/6;
          else if(max===G)h=((B-R)/d+2)/6;
          else h=((R-G)/d+4)/6;
        }
        h=Math.round(h*360);s=Math.round(s*100);l=Math.round(l*100);
      }
      for(let r=1;r<=voiceLevel;r++){
        const rr=half-r*(half/(voiceLevel+1.5));
        const darkL=Math.max(0,l-r*10); // decrease lightness by 10% per ring
        ringsHTML+=`<circle cx="${half}" cy="${half}" r="${rr}" fill="hsl(${h},${s}%,${darkL}%)" />`;
      }
      ringsHTML+='</svg>';
    }
    const voiceTag=voiceLevel>0?` ${['','7th','9th','11th'][voiceLevel]}`:'';
    const noteCount=voiceLevel>0?[3,4,5,6][voiceLevel]+'â™ª':'';
    const fontSize=Math.max(9,Math.round(pR*0.38*petalScale));
    // Text rendered after SVG so it sits on top
    const newHTML=`${ringsHTML}<span class="petal-label" style="font-size:${fontSize}px;position:relative;z-index:2">${showNames?ch.name+voiceTag:noteCount}</span>`;
    if(el._lastHTML!==newHTML){el.innerHTML=newHTML;el._lastHTML=newHTML;}

    // Attach event handlers only once
    if(!el._eventsAttached){
      el._eventsAttached=true;
      // Use pointerup instead of click â€” iOS Safari suppresses click
      // on elements with pointerdown handlers
      el.addEventListener('pointerup',(e)=>{
        if(el._wasDragged)return;
        e.stopPropagation();
        const{ch:c,i:idx,voiceLevel:vl}=el._chordData;
        selectedPetal=idx===selectedPetal?-1:idx;
        // Send MIDI immediately (don't wait for audio)
        sendMIDIChord(c.root,c.quality);
        const ext=VOICING_EXTENSIONS[c.quality];
        if(improvEnabled){
          // Generate improv first, then play chord + improv simultaneously
          const intervals=ext&&ext[vl]?ext[vl]:(QUALITY[c.quality]?.intervals||[0,4,7]);
          improviseOverChord(c.root,c.quality,()=>playChordNotes(c.root,intervals));
        } else {
          if(ext&&ext[vl])playChordIntervals(c.root,ext[vl]);
          else playChord(c.root,c.quality);
        }
        // Spring animation
        const bp=el._basePos||{x:0,y:0};
        const baseT=`translate(${bp.x}px,${bp.y}px)`;
        el.style.transition='transform 0.1s ease-out';
        el.style.transform=baseT+' scale(0.88)';
        setTimeout(()=>{el.style.transition='transform 0.3s cubic-bezier(0.34,1.56,0.64,1)';el.style.transform=baseT+' scale(1.06)';},100);
        setTimeout(()=>{el.style.transition='transform 0.25s cubic-bezier(0.34,1.2,0.64,1)';el.style.transform=baseT+' scale(0.97)';},350);
        setTimeout(()=>{el.style.transition='transform 0.2s ease-out';el.style.transform=baseT;render();},550);
      });

      let tapC=0,tapT,longPressT;
      el.addEventListener('pointerdown',(ev)=>{
        el._wasDragged=false; // reset from previous long-press
        const{ch:c,i:idx}=el._chordData;
        tapC++;
        if(tapC===2){
          clearTimeout(tapT);tapC=0;
          if(!lockRoot)setRoot(c.root,c.name);
          else{delete petalCustomOffsets[idx];render();}
          return;
        }
        tapT=setTimeout(()=>tapC=0,350);
        longPressT=setTimeout(()=>{
          const cur=petalVoicings[idx]||0;
          petalVoicings[idx]=(cur+1)%4;
          el._wasDragged=true; // suppress pointerup sound after long-press
          render();
          const vl2=petalVoicings[idx];
          const ext2=VOICING_EXTENSIONS[c.quality];
          if(ext2&&ext2[vl2])playChordIntervals(c.root,ext2[vl2]);
        },500);
      });
      el.addEventListener('pointerup',()=>clearTimeout(longPressT));
      el.addEventListener('pointermove',()=>clearTimeout(longPressT));
    }
  });

  // â”€â”€ Sub-petals (voicing variants in outer ring) â”€â”€
  const subNeeded=subPetals.length;
  while(subPetalElements.length>subNeeded){const el=subPetalElements.pop();el.remove();}
  while(subPetalElements.length<subNeeded){
    const el=document.createElement('div');
    el.className='petal';
    el.style.boxShadow='none';
    garden.appendChild(el);
    subPetalElements.push(el);
  }
  const subPetalScale=0.7;
  const subDiam=Math.round(pR*2*subPetalScale);

  subPetals.forEach((sp,si)=>{
    if(sp.parentIdx>=chords.length)return;
    const parentPos=packPositions[sp.parentIdx];
    if(!parentPos)return;

    // Sync sub-petal voicing with parent's current voicing level
    const parentVL=petalVoicings[sp.parentIdx]||0;
    if(sp.voiceLevel!==parentVL){
      sp.voiceLevel=parentVL;
      // Update alt voicing intervals for new note count
      const parentChordTmp=chords[sp.parentIdx];
      const extTmp=VOICING_EXTENSIONS[parentChordTmp.quality];
      const baseIntTmp=extTmp?extTmp[parentVL]:QUALITY[parentChordTmp.quality]?.intervals||[0,4,7];
      const ncTmp=baseIntTmp.length;
      const altsTmp=getAltVoicings(parentChordTmp.quality,ncTmp);
      if(altsTmp&&sp.altIdx<altsTmp.length){
        const alt=altsTmp[sp.altIdx];
        sp.altName=alt.name;sp.altIntervals=alt.intervals;
      }
    }

    // Place sub-petals just beyond the parent, offset by alt voicing index
    const pAngle=Math.atan2(parentPos.y,parentPos.x);
    const altIdx=sp.altIdx||sp.voiceLevel||1;
    const angleOffset=(altIdx-1)*0.4-0.2;
    const pDist=Math.sqrt(parentPos.x*parentPos.x+parentPos.y*parentPos.y);
    const subR=pDist+pR*1.1;
    const angle=pAngle+angleOffset;
    const px=cx+subR*Math.cos(angle);
    const py=cy+subR*Math.sin(angle);
    const parentChord=chords[sp.parentIdx];
    const qi=QUALITY[parentChord.quality]||QUALITY.major;
    // Desaturated version of parent color
    const solidColor=qi.solid;
    const desat=desatColor(solidColor,0.5,0.45);

    const el=subPetalElements[si];
    el.style.transform=`translate(${px-subDiam/2}px,${py-subDiam/2}px)`;
    el.style.width=subDiam+'px';el.style.height=subDiam+'px';
    el.style.left='0';el.style.top='0';
    el.style.background=desat;
    el.style.opacity='0.85';
    el.dataset.subIndex=si;
    el._subData={sp,parentChord,si};

    // Build voicing rings for sub-petals (same style as main petals)
    let subRingsHTML='';
    if(parentVL>0){
      const half=subDiam/2;
      const hexMatch=solidColor.match(/#([0-9a-f]{6})/i);
      let h=0,s=0,l=50;
      if(hexMatch){
        let R=parseInt(hexMatch[1].slice(0,2),16)/255;
        let G=parseInt(hexMatch[1].slice(2,4),16)/255;
        let B=parseInt(hexMatch[1].slice(4,6),16)/255;
        const max=Math.max(R,G,B),min=Math.min(R,G,B);
        l=(max+min)/2;
        if(max!==min){
          const d=max-min;
          s=l>0.5?d/(2-max-min):d/(max+min);
          if(max===R)h=((G-B)/d+(G<B?6:0))/6;
          else if(max===G)h=((B-R)/d+2)/6;
          else h=((R-G)/d+4)/6;
        }
        h=Math.round(h*360);s=Math.round(s*100);l=Math.round(l*100);
      }
      // Use desaturated base lightness for sub-petal rings
      const desatL=Math.max(0,l-15);
      subRingsHTML=`<svg class="petal-rings" viewBox="0 0 ${subDiam} ${subDiam}" width="${subDiam}" height="${subDiam}">`;
      for(let r=1;r<=parentVL;r++){
        const rr=half-r*(half/(parentVL+1.5));
        const darkL=Math.max(0,desatL-r*10);
        subRingsHTML+=`<circle cx="${half}" cy="${half}" r="${rr}" fill="hsl(${h},${Math.round(s*0.5)}%,${darkL}%)" />`;
      }
      subRingsHTML+='</svg>';
    }

    const voiceLabel=sp.altName||VOICING_LABELS[sp.voiceLevel]||'';
    const fontSize=Math.max(8,Math.round(pR*0.3*subPetalScale));
    const displayName=showNames?parentChord.name+'\n'+voiceLabel:voiceLabel;
    const newHTML=`${subRingsHTML}<span class="petal-label" style="font-size:${fontSize}px;line-height:1.1;position:relative;z-index:2">${displayName}</span>`;
    if(el._lastHTML!==newHTML){el.innerHTML=newHTML;el._lastHTML=newHTML;}

    if(!el._eventsAttached){
      el._eventsAttached=true;
      el.addEventListener('pointerup',(e)=>{
        if(el._wasDragged)return;
        e.stopPropagation();
        const{sp:s,parentChord:pc}=el._subData;
        // Play alternate voicing intervals if available, otherwise fall back
        if(s.altIntervals){
          playChordIntervals(pc.root,s.altIntervals);
        }else{
          const ext=VOICING_EXTENSIONS[pc.quality];
          if(ext&&ext[s.voiceLevel])playChordIntervals(pc.root,ext[s.voiceLevel]);
          else playChord(pc.root,pc.quality);
        }
        sendMIDIChord(pc.root,pc.quality);
        // Spring animation
        const baseT=el.style.transform.replace(/ scale\([^)]*\)/g,'');
        el.style.transition='transform 0.1s ease-out';
        el.style.transform=baseT+' scale(0.85)';
        setTimeout(()=>{el.style.transition='transform 0.3s cubic-bezier(0.34,1.56,0.64,1)';el.style.transform=baseT+' scale(1.06)';},100);
        setTimeout(()=>{el.style.transition='transform 0.2s ease-out';el.style.transform=baseT;},350);
      });
    }
  });

  // History
  const hEl=document.getElementById('history');
  hEl.innerHTML='';
  history_stack.forEach((h,i)=>{
    if(i>0){const a=document.createElement('span');a.className='arrow';a.textContent=' â†’ ';hEl.appendChild(a);}
    const s=document.createElement('span');s.textContent=h.name;
    s.onclick=()=>{currentRoot=h.root;history_stack=history_stack.slice(0,i+1);redoStack=[];petalCustomOffsets={};selectedPetal=-1;render();};
    hEl.appendChild(s);
  });
  hEl.scrollLeft=hEl.scrollWidth;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAG SYSTEM (petals + rotation ring)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initDragSystem(){
  const garden=document.getElementById('garden');
  let dragTarget=null,dragType=null,startX,startY,startAngle;

  function getPos(e){const t=e.touches?e.touches[0]:e;return{x:t.clientX,y:t.clientY};}
  function gardenRect(){return garden.getBoundingClientRect();}

  // Petal drag (main + sub-petals)
  garden.addEventListener('pointerdown',(e)=>{
    // Don't intercept +/- buttons
    if(e.target.closest('.petal-count'))return;
    const petal=e.target.closest('.petal');
    const ring=e.target.closest('.rotation-ring');
    if(petal){
      dragTarget=petal;
      dragType=petal.dataset.subIndex!==undefined?'subpetal':'petal';
      petal._wasDragged=false;
      petal._dragCaptured=false;
      petal._pointerId=e.pointerId;
      const p=getPos(e);startX=p.x;startY=p.y;
      // Don't setPointerCapture or preventDefault here â€” 
      // doing so on iOS suppresses the click event.
      // We'll capture only once actual drag movement is detected.
    }else if(ring){
      dragType='ring';dragTarget=ring;
      const p=getPos(e);const r=gardenRect();
      const cx=r.left+r.width/2,cy=r.top+r.height/2;
      startAngle=Math.atan2(p.y-cy,p.x-cx)*180/Math.PI-globalRotation;
      ring.setPointerCapture(e.pointerId);
      e.preventDefault();
    }
  });

  garden.addEventListener('pointermove',(e)=>{
    if(!dragTarget)return;
    e.preventDefault();
    const p=getPos(e);
    if(dragType==='petal'||dragType==='subpetal'){
      const dx=p.x-startX,dy=p.y-startY;
      if(Math.abs(dx)+Math.abs(dy)>5){
        dragTarget._wasDragged=true;
        // Capture pointer and start visual drag only once threshold exceeded
        if(!dragTarget._dragCaptured){
          dragTarget._dragCaptured=true;
          dragTarget.classList.add('dragging');
          try{dragTarget.setPointerCapture(dragTarget._pointerId);}catch(e){}
        }
      }
      if(!dragTarget._wasDragged)return; // Don't move petal until drag threshold met
      const r=gardenRect();
      const cx=r.width/2,cy=r.height/2;
      const lx=p.x-r.left,ly=p.y-r.top;
      const halfW=parseFloat(dragTarget.style.width)/2;
      dragTarget.style.transform=`translate(${lx-halfW}px,${ly-halfW}px)`;
      dragTarget.style.transition='width .1s,height .1s,box-shadow .1s';
      if(dragType==='petal'){
        const idx=parseInt(dragTarget.dataset.index);
        petalCustomOffsets[idx]={dx:lx-cx,dy:ly-cy};
      }
      // Show delete ring and check if outside
      const delRing=document.getElementById('deleteRing');
      const dist=Math.sqrt((lx-cx)**2+(ly-cy)**2);
      const ringR=parseFloat(delRing.style.width)/2;
      delRing.classList.add('active');
      if(dist>ringR){delRing.classList.add('danger');dragTarget.style.opacity='0.5';}
      else{delRing.classList.remove('danger');dragTarget.style.opacity='1';}
    }else if(dragType==='ring'){
      const r=gardenRect();
      const cx=r.left+r.width/2,cy=r.top+r.height/2;
      const angle=Math.atan2(p.y-cy,p.x-cx)*180/Math.PI;
      globalRotation=angle-startAngle;
      render();
    }
  });

  garden.addEventListener('pointerup',(e)=>{
    const delRing=document.getElementById('deleteRing');
    delRing.classList.remove('active','danger');
    if(dragTarget&&(dragType==='petal'||dragType==='subpetal')){
      dragTarget.classList.remove('dragging');
      dragTarget.style.transition='';
      dragTarget.style.opacity='1';
      // Check if outside delete ring â†’ remove petal
      const r=gardenRect();
      const cx=r.width/2,cy=r.height/2;
      const p=getPos(e);
      const lx=p.x-r.left,ly=p.y-r.top;
      const dist=Math.sqrt((lx-cx)**2+(ly-cy)**2);
      const ringR=parseFloat(delRing.style.width)/2;
      if(dragTarget._wasDragged&&dist>ringR){
        if(dragType==='subpetal'){
          const si=parseInt(dragTarget.dataset.subIndex);
          subPetals.splice(si,1);
          render();
        }else if(petalCount>3){
          const idx=parseInt(dragTarget.dataset.index);
          delete petalCustomOffsets[idx];
          // Also remove sub-petals for this parent and shift indices
          subPetals=subPetals.filter(sp=>sp.parentIdx!==idx).map(sp=>({...sp,parentIdx:sp.parentIdx>idx?sp.parentIdx-1:sp.parentIdx}));
          petalCount=Math.max(3,petalCount-1);
          document.getElementById('petalCountLabel').textContent=petalCount;
          render();
        }
      }else{
        if(dragType==='petal'){
          const idx=parseInt(dragTarget.dataset.index);
          if(dragTarget._wasDragged){delete petalCustomOffsets[idx];}
        }
        render();
      }
    }
    dragTarget=null;dragType=null;
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MIDI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let midiAccess=null,midiOutPort=null,midiInPort=null;
let midiActiveNotes=new Set(),midiHeldNotes=new Set(),midiNoteOffTimers={};

function toggleVoicePanel(){
  document.getElementById('voicePanel').classList.toggle('open');
  document.getElementById('midiPanel').classList.remove('open');
}
function toggleBass(v){bassRoot=v;}
function previewChord(){playChord(currentRoot,'major');}
function setSynth(s){
  synthPreset=s;
  // If picking a Sonic Pi preset, force SuperSonic mode; warn if not ready
  if(SONIC_PI_PRESETS.has(s)){
    if(!sonicReady){
      // Boot SuperSonic if not already running
      if(!sonicLoading)initSuperSonic();
    }
    window._useWebAudio=false;
    const badge=document.getElementById('engineBadge');
    if(badge){badge.textContent='âš¡ SuperSonic';badge.style.background='rgba(61,173,217,0.2)';badge.style.color='#3DADD9';}
  }
  document.querySelectorAll('[data-synth]').forEach(b=>b.classList.toggle('active',b.dataset.synth===s));
  previewChord();
}
function shiftOctave(dir){
  octaveShift=Math.max(-2,Math.min(2,octaveShift+dir));
  document.getElementById('octaveLabel').textContent=(octaveShift>0?'+':'')+octaveShift;
  previewChord();
}
function setVoiceMode(m){
  voicingMode=m;
  document.querySelectorAll('[data-voice]').forEach(b=>b.classList.toggle('active',b.dataset.voice===m));
  previewChord();
}
function setPhraseMode(m){
  phraseMode=m;
  document.querySelectorAll('[data-phrase]').forEach(b=>b.classList.toggle('active',b.dataset.phrase===m));
  previewChord();
}
function toggleMidiPanel(){document.getElementById('midiPanel').classList.toggle('open');document.getElementById('voicePanel').classList.remove('open');}
function closeMidiPanel(){
  const panel=document.getElementById('midiPanel');
  panel.classList.remove('open');
  panel._justClosed=true;
  setTimeout(()=>{delete panel._justClosed;},300);
}
document.addEventListener('pointerdown',(e)=>{
  const panel=document.getElementById('midiPanel');
  if(panel.classList.contains('open')&&!panel.contains(e.target)&&!e.target.closest('[onclick*="toggleMidiPanel"]')){
    closeMidiPanel();
  }
  const vPanel=document.getElementById('voicePanel');
  if(vPanel.classList.contains('open')&&!vPanel.contains(e.target)&&!e.target.closest('[onclick*="toggleVoicePanel"]')){
    vPanel.classList.remove('open');
    vPanel._justClosed=true;setTimeout(()=>{delete vPanel._justClosed;},300);
  }
  const iPanel=document.getElementById('improvPanel');
  if(iPanel.classList.contains('open')&&!iPanel.contains(e.target)&&!e.target.closest('[onclick*="toggleImprov"]')){
    iPanel.classList.remove('open');
    iPanel._justClosed=true;setTimeout(()=>{delete iPanel._justClosed;},300);
  }
});
function buildMidiChannels(){const s=document.getElementById('midiCh');for(let i=1;i<=16;i++){const o=document.createElement('option');o.value=i;o.textContent='Ch '+i;s.appendChild(o);}}

async function initMIDI(){
  if(!navigator.requestMIDIAccess)return;
  try{
    midiAccess=await navigator.requestMIDIAccess({sysex:false});
    populateMIDIDevices();
    midiAccess.onstatechange=()=>populateMIDIDevices();
  }catch(e){}
}

function populateMIDIDevices(){
  const outSel=document.getElementById('midiOut'),inSel=document.getElementById('midiIn');
  const prevOut=outSel.value,prevIn=inSel.value;
  outSel.innerHTML='<option value="">None</option>';
  inSel.innerHTML='<option value="">None</option>';
  for(const[id,port]of midiAccess.outputs){const o=document.createElement('option');o.value=id;o.textContent=port.name;outSel.appendChild(o);}
  for(const[id,port]of midiAccess.inputs){const o=document.createElement('option');o.value=id;o.textContent=port.name;inSel.appendChild(o);}
  if(prevOut)outSel.value=prevOut;if(prevIn)inSel.value=prevIn;
  selectMIDIOut();selectMIDIIn();
}

document.getElementById('midiOut').addEventListener('change',selectMIDIOut);
document.getElementById('midiIn').addEventListener('change',selectMIDIIn);

function selectMIDIOut(){const id=document.getElementById('midiOut').value;midiOutPort=id&&midiAccess?midiAccess.outputs.get(id):null;}
function selectMIDIIn(){
  if(midiInPort)midiInPort.onmidimessage=null;
  const id=document.getElementById('midiIn').value;
  midiInPort=id&&midiAccess?midiAccess.inputs.get(id):null;
  if(midiInPort)midiInPort.onmidimessage=onMIDIMessage;
  midiHeldNotes.clear();
}

function sendMIDIChord(rootNote,quality){
  if(!midiOutPort||!document.getElementById('midiSendToggle').checked)return;
  const ch=parseInt(document.getElementById('midiCh').value)||1;
  const statusOn=0x90+(ch-1),statusOff=0x80+(ch-1);
  const intervals=QUALITY[quality]?.intervals||[0,4,7];
  const base=60+rootNote;
  midiActiveNotes.forEach(n=>{midiOutPort.send([statusOff,n,0]);});
  Object.values(midiNoteOffTimers).forEach(clearTimeout);midiNoteOffTimers={};midiActiveNotes.clear();
  const notes=intervals.map(i=>base+i);
  notes.forEach(n=>{midiOutPort.send([statusOn,n,100]);midiActiveNotes.add(n);});
  const timer=setTimeout(()=>{notes.forEach(n=>{if(midiActiveNotes.has(n)){midiOutPort.send([statusOff,n,0]);midiActiveNotes.delete(n);}});},500);
  notes.forEach(n=>midiNoteOffTimers[n]=timer);
}

function onMIDIMessage(ev){
  const[status,note,vel]=ev.data;const cmd=status&0xf0;
  if(cmd===0x90&&vel>0)midiHeldNotes.add(note);
  else if(cmd===0x80||(cmd===0x90&&vel===0))midiHeldNotes.delete(note);
  else return;
  detectChordFromMIDI();
}

const CHORD_TEMPLATES=[
  {name:'major',intervals:[0,4,7]},{name:'minor',intervals:[0,3,7]},
  {name:'dim',intervals:[0,3,6]},{name:'aug',intervals:[0,4,8]},
  {name:'dom7',intervals:[0,4,7,10]},{name:'maj7',intervals:[0,4,7,11]},
  {name:'min7',intervals:[0,3,7,10]},{name:'halfdim',intervals:[0,3,6,10]},
  {name:'dim7',intervals:[0,3,6,9]},{name:'sus2',intervals:[0,2,7]},{name:'sus4',intervals:[0,5,7]},
];

function detectChordFromMIDI(){
  const el=document.getElementById('midiDetected');
  if(midiHeldNotes.size<3){el.textContent='';return;}
  const pcs=[...new Set([...midiHeldNotes].map(n=>n%12))].sort((a,b)=>a-b);
  let best=null;
  for(const tmpl of CHORD_TEMPLATES){
    for(const root of pcs){
      const expected=tmpl.intervals.map(i=>(root+i)%12).sort((a,b)=>a-b);
      if(expected.length===pcs.length&&expected.every((v,i)=>v===pcs[i])){
        best={root,quality:tmpl.name,name:noteName(root,true)+qualitySuffix(tmpl.name)};break;
      }
    }
    if(best)break;
  }
  if(!best){el.textContent='ğŸ¹ '+[...midiHeldNotes].map(n=>noteName(n%12,true)).join(' ');return;}
  el.textContent='ğŸ¹ '+best.name;
  if(document.getElementById('midiNavToggle').checked){setTimeout(()=>setRoot(best.root,best.name),300);}
}

initMIDI();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BLUETOOTH MIDI (BLE MIDI)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BLE_MIDI_SERVICE='03b80e5a-ede8-4b33-a751-6ce34ec4c700';
const BLE_MIDI_CHAR='7772e5db-3868-4112-a1a9-f2669d106bf3';
let bleDevice=null, bleChar=null, bleMidiConnected=false;

function setBLEStatus(msg,ok){
  const el=document.getElementById('bleMidiStatus');
  el.textContent=msg;
  el.style.color=ok?'#3DADD9':'var(--text-dim)';
  document.getElementById('bleMidiBtn').textContent=bleMidiConnected?'â Disconnect BLE':'ğŸ”— Connect BLE Device';
}

async function connectBLEMIDI(){
  // If already connected, disconnect
  if(bleMidiConnected&&bleDevice){
    bleDevice.gatt.disconnect();
    bleMidiConnected=false;
    bleChar=null;
    setBLEStatus('Disconnected');
    return;
  }
  
  if(!navigator.bluetooth){
    setBLEStatus('Bluetooth not available on this browser');
    return;
  }
  
  try{
    setBLEStatus('Scanningâ€¦');
    bleDevice=await navigator.bluetooth.requestDevice({
      filters:[{services:[BLE_MIDI_SERVICE]}],
      optionalServices:[BLE_MIDI_SERVICE]
    });
    
    bleDevice.addEventListener('gattserverdisconnected',()=>{
      bleMidiConnected=false;
      bleChar=null;
      setBLEStatus('Disconnected');
    });
    
    setBLEStatus('Connectingâ€¦');
    const server=await bleDevice.gatt.connect();
    const service=await server.getPrimaryService(BLE_MIDI_SERVICE);
    bleChar=await service.getCharacteristic(BLE_MIDI_CHAR);
    
    // Enable notifications for incoming MIDI
    await bleChar.startNotifications();
    bleChar.addEventListener('characteristicvaluechanged',onBLEMIDIMessage);
    
    bleMidiConnected=true;
    setBLEStatus('âœ“ '+bleDevice.name,true);
    
    // Also add as MIDI output option
    populateMIDIDevices();
  }catch(e){
    if(e.name==='NotFoundError'){
      setBLEStatus('No device selected');
    }else{
      console.error('BLE MIDI error:',e);
      setBLEStatus('Error: '+e.message);
    }
  }
}

// Parse BLE MIDI packet (BLE MIDI spec: timestamp header + MIDI bytes)
function onBLEMIDIMessage(event){
  const data=new Uint8Array(event.target.value.buffer);
  if(data.length<3)return;
  // BLE MIDI packet: [header, timestamp, status, data1, data2, ...]
  // Header byte has bit 7 set, timestamp byte has bit 7 set
  let i=0;
  // Skip header byte
  if(data[i]&0x80)i++;
  
  let runningStatus=0;
  while(i<data.length){
    // Skip timestamp bytes (bit 7 set, but not a status byte in context)
    if(data[i]&0x80&&i<data.length-1){
      // Could be timestamp or status byte
      const b=data[i];
      if((b&0xF0)>=0x80&&(b&0xF0)<=0xE0){
        // It's a MIDI status byte
        runningStatus=b;
        i++;
      }else{
        // Timestamp byte, skip
        i++;
        continue;
      }
    }
    
    if(!runningStatus)break;
    const cmd=runningStatus&0xF0;
    
    if(cmd===0x90||cmd===0x80){
      if(i+1>=data.length)break;
      const note=data[i]&0x7F;
      const vel=data[i+1]&0x7F;
      i+=2;
      
      // Route to existing MIDI input handler
      if(cmd===0x90&&vel>0)midiHeldNotes.add(note);
      else midiHeldNotes.delete(note);
      detectChordFromMIDI();
      
      // Show in MIDI note display
      const el=document.getElementById('midiNote');
      el.textContent='BLE: '+noteName(note%12,true)+(Math.floor(note/12)-1)+' vel:'+vel;
    }else{
      // Skip other message types (2 data bytes for most)
      i+=2;
    }
  }
}

// Send MIDI data over BLE
function sendBLEMIDI(bytes){
  if(!bleChar||!bleMidiConnected)return;
  // BLE MIDI packet: [header, timestamp, ...midi bytes]
  const ts=Date.now()&0x1FFF; // 13-bit timestamp
  const header=0x80|((ts>>7)&0x3F);
  const tsLow=0x80|(ts&0x7F);
  const packet=new Uint8Array([header,tsLow,...bytes]);
  bleChar.writeValueWithoutResponse(packet).catch(e=>console.warn('BLE send error:',e));
}

// Patch sendMIDIChord to also send over BLE
const _origSendMIDIChord=sendMIDIChord;
sendMIDIChord=function(rootNote,quality){
  _origSendMIDIChord(rootNote,quality);
  if(!bleMidiConnected||!bleChar)return;
  if(!document.getElementById('midiSendToggle').checked)return;
  const ch=parseInt(document.getElementById('midiCh').value)||1;
  const statusOn=0x90+(ch-1),statusOff=0x80+(ch-1);
  const intervals=QUALITY[quality]?.intervals||[0,4,7];
  const base=60+rootNote;
  const notes=intervals.map(i=>base+i);
  // Send note-ons
  notes.forEach(n=>sendBLEMIDI([statusOn,n,100]));
  // Schedule note-offs
  setTimeout(()=>{notes.forEach(n=>sendBLEMIDI([statusOff,n,0]));},500);
};

// Debounced resize handler
let _resizeRAF=0;
function onResize(){
  if(_resizeRAF)cancelAnimationFrame(_resizeRAF);
  _resizeRAF=requestAnimationFrame(()=>{cacheGardenDims();render();_resizeRAF=0;});
}
// Wait for layout to complete before first render
requestAnimationFrame(()=>requestAnimationFrame(()=>{
  cacheGardenDims();
  init();
  window.addEventListener('resize',onResize,{passive:true});
}));

// Wire up +/- buttons with addEventListener (onclick can fail on iOS)
document.getElementById('addBtn').addEventListener('touchend',(e)=>{e.preventDefault();e.stopPropagation();addPetal();},{passive:false});
document.getElementById('addBtn').addEventListener('click',(e)=>{e.stopPropagation();addPetal();});
document.getElementById('removeBtn').addEventListener('touchend',(e)=>{e.preventDefault();e.stopPropagation();removePetal();},{passive:false});
document.getElementById('removeBtn').addEventListener('click',(e)=>{e.stopPropagation();removePetal();});
</script>
</body>
</html>
